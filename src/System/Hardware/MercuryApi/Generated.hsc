-- Automatically generated by util/generate-tmr-hsc.pl
{-# LANGUAGE OverloadedStrings, FlexibleInstances, DeriveDataTypeable #-}
module System.Hardware.MercuryApi.Generated where

import Control.Applicative
import Control.Exception
import Data.Hashable
import Data.ByteString (ByteString)
import qualified Data.ByteString as B
import Data.Maybe
import Data.Monoid
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Encoding.Error as T
import Data.Typeable
import Data.Word
import Foreign
import Foreign.C

#include <tm_reader.h>
#include <glue.h>
#include <stdbool.h>

-- | A GPIO pin number.  On the M6e Nano, these are numbered 1-4.
type PinNumber = Word8

-- | An antenna number.  On the
-- <https://www.sparkfun.com/products/14066 SparkFun Simultaneous RFID Reader>,
-- there is a single antenna with the number 1.
type AntennaPort = Word8

-- | A 32-bit password (access or kill) in the Gen2 protocol.
type GEN2_Password = Word32

-- | milliseconds since 1\/1\/1970 UTC
type MillisecondsSinceEpoch = Word64

-- | Version number of the Mercury API C library.
apiVersion :: Text
apiVersion = #{const_str TMR_VERSION}

type CBool = #{type bool}
newtype ReaderEtc = ReaderEtc ()

cFalse, cTrue :: CBool
cFalse = 0
cTrue = 1

toBool' :: CBool -> Bool
toBool' = toBool

fromBool' :: Bool -> CBool
fromBool' = fromBool

sizeofReaderEtc :: Int
sizeofReaderEtc = #{size ReaderEtc}

uriPtr :: Ptr ReaderEtc -> CString
uriPtr = #{ptr ReaderEtc, reader.uri}

-- I'm not sure what encoding MercuryApi uses for its strings.
-- I'm guessing UTF-8 for now, but the encoding is encapsulated in
-- these two functions (textFromBS and textToBS) so it can be
-- easily changed.
textFromBS :: ByteString -> Text
textFromBS = T.decodeUtf8With T.lenientDecode

textToBS :: Text -> ByteString
textToBS = T.encodeUtf8

textFromCString :: CString -> IO Text
textFromCString cs = textFromBS <$> B.packCString cs

-- This exception is never seen by the user.  It is caught
-- internally and turned into a MercuryException (with some added fields).
data ParamException = ParamException StatusType Status Text
  deriving (Eq, Ord, Show, Read, Typeable)

instance Exception ParamException

castLen' :: Integral a => a -> Text -> Int -> IO a
castLen' bound description x = do
  let tShow = T.pack . show
      maxLen = fromIntegral bound
  if x > maxLen
    then throwIO ( ParamException ERROR_TYPE_MISC ERROR_TOO_BIG $
                   description <> " had length " <> tShow x <>
                   " but maximum is " <> tShow maxLen )
    else return $ fromIntegral x

castLen :: (Integral a, Bounded a) => Text -> Int -> IO a
castLen = castLen' maxBound

-- | A class for types which can be used as parameter values.
class ParamValue a where
  pType :: a -> ParamType
  pGet :: (Ptr () -> IO ()) -> IO a
  pSet :: a -> (Ptr () -> IO ()) -> IO ()

-- | A ReadPlan record specifies the antennas, protocols, and filters
-- to use for a search (read).
--
-- Currently, only @SimpleReadPlan@ is supported.
data ReadPlan =
  SimpleReadPlan
  { rpWeight        :: !Word32          -- ^ The relative weight of this read plan
  , rpEnableAutonomousRead :: !Bool     -- ^ Option for Autonomous read
  , rpAntennas      :: ![AntennaPort]   -- ^ The list of antennas to read on
  , rpProtocol      :: !TagProtocol     -- ^ The protocol to use for reading
  , rpFilter        :: !(Maybe TagFilter) -- ^ The filter to apply to reading
  , rpTagop         :: !(Maybe TagOp)   -- ^ The tag operation to apply to
                                        -- each read tag
  , rpUseFastSearch :: !Bool            -- ^ Option to use the FastSearch
  , rpStopOnCount   :: !(Maybe Word32)  -- ^ Number of tags to be read
  , rpTriggerRead   :: !(Maybe [Word8]) -- ^ The list of GPI ports which should
                                        -- be used to trigger the read
  } deriving (Eq, Ord, Show, Read)

antennasInfo :: Ptr ReadPlan -> (Ptr List16, Word16, Ptr Word8, Text)
antennasInfo rp =
  ( #{ptr ReadPlanEtc, plan.u.simple.antennas} rp
  , #{const GLUE_MAX_ANTENNAS}
  , #{ptr ReadPlanEtc, antennas} rp
  , "rpAntennas"
  )

gpiListInfo :: Ptr ReadPlan -> (Ptr List16, Word16, Ptr Word8, Text)
gpiListInfo rp =
  ( #{ptr ReadPlanEtc, plan.u.simple.triggerRead.gpiList} rp
  , #{const GLUE_MAX_GPIPORTS}
  , #{ptr ReadPlanEtc, gpiPorts} rp
  , "rpTriggerRead"
  )

readPlanTypeSimple :: #{type TMR_ReadPlanType}
readPlanTypeSimple = #{const TMR_READ_PLAN_TYPE_SIMPLE}

instance Storable ReadPlan where
  sizeOf _ = #{size ReadPlanEtc}
  alignment _ = 8

  poke p x = do
    #{poke ReadPlanEtc, plan.type} p readPlanTypeSimple
    #{poke ReadPlanEtc, plan.weight} p (rpWeight x)
    #{poke ReadPlanEtc, plan.enableAutonomousRead} p
      (fromBool' $ rpEnableAutonomousRead x)
    pokeList16 (antennasInfo p) (rpAntennas x)
    #{poke ReadPlanEtc, plan.u.simple.protocol} p
      (fromTagProtocol $ rpProtocol x)
    case rpFilter x of
      Nothing -> #{poke ReadPlanEtc, plan.u.simple.filter} p nullPtr
      Just f -> do
        #{poke ReadPlanEtc, filter} p f
        #{poke ReadPlanEtc, plan.u.simple.filter} p (#{ptr ReadPlanEtc, filter} p)
    case rpTagop x of
      Nothing -> #{poke ReadPlanEtc, plan.u.simple.tagop} p nullPtr
      Just op -> do
        #{poke ReadPlanEtc, tagop} p op
        #{poke ReadPlanEtc, plan.u.simple.tagop} p (#{ptr ReadPlanEtc, tagop} p)
    #{poke ReadPlanEtc, plan.u.simple.useFastSearch} p
      (fromBool' $ rpUseFastSearch x)
    let (stop, nTags) = case rpStopOnCount x of
                          Nothing -> (cFalse, 0)
                          Just n -> (cTrue, n)
    #{poke ReadPlanEtc, plan.u.simple.stopOnCount.stopNTriggerStatus} p stop
    #{poke ReadPlanEtc, plan.u.simple.stopOnCount.noOfTags} p nTags
    let (enable, ports) = case rpTriggerRead x of
                            Nothing -> (cFalse, [])
                            Just ps -> (cTrue, ps)
    #{poke ReadPlanEtc, plan.u.simple.triggerRead.enable} p enable
    pokeList16 (gpiListInfo p) ports

  peek p = do
    weight <- #{peek ReadPlanEtc, plan.weight} p
    enableAutonomousRead <- #{peek ReadPlanEtc, plan.enableAutonomousRead} p
    antennas <- peekList16 (antennasInfo p)
    protocol <- #{peek ReadPlanEtc, plan.u.simple.protocol} p
    fPtr <- #{peek ReadPlanEtc, plan.u.simple.filter} p
    filt <- if fPtr == nullPtr
            then return Nothing
            else Just <$> peek fPtr
    opPtr <- #{peek ReadPlanEtc, plan.u.simple.tagop} p
    op <- if opPtr == nullPtr
          then return Nothing
          else Just <$> peek opPtr
    useFastSearch <- #{peek ReadPlanEtc, plan.u.simple.useFastSearch} p
    stop <- #{peek ReadPlanEtc, plan.u.simple.stopOnCount.stopNTriggerStatus} p
    stopOnCount <- if toBool' stop
                   then Just <$> #{peek ReadPlanEtc, plan.u.simple.stopOnCount.noOfTags} p
                   else return Nothing
    enable <- #{peek ReadPlanEtc, plan.u.simple.triggerRead.enable} p
    triggerRead <- if toBool' enable
                   then Just <$> peekList16 (gpiListInfo p)
                   else return Nothing
    return $ SimpleReadPlan
      { rpWeight = weight
      , rpEnableAutonomousRead = toBool' enableAutonomousRead
      , rpAntennas = antennas
      , rpProtocol = toTagProtocol protocol
      , rpFilter = filt
      , rpTagop = op
      , rpUseFastSearch = toBool' useFastSearch
      , rpStopOnCount = stopOnCount
      , rpTriggerRead = triggerRead
      }

-- | Filter on EPC length, or on a Gen2 bank.
data FilterOn = FilterOnBank GEN2_Bank
              | FilterOnEpcLength
              deriving (Eq, Ord, Show, Read)

instance Storable FilterOn where
  sizeOf _ = #{size TMR_GEN2_Bank}
  alignment _ = 8

  poke p FilterOnEpcLength = do
    let p' = castPtr p :: Ptr RawBank
    poke p' #{const TMR_GEN2_EPC_LENGTH_FILTER}

  poke p (FilterOnBank bank) = do
    let p' = castPtr p :: Ptr RawBank
    poke p' (fromBank bank)

  peek p = do
    x <- peek (castPtr p)
    if x == #{const TMR_GEN2_EPC_LENGTH_FILTER}
      then return FilterOnEpcLength
      else return $ FilterOnBank $ toBank x

-- | Filter on EPC data, or on Gen2-specific information.
data TagFilter = TagFilterEPC TagData
               | TagFilterGen2
               { tfInvert        :: !Bool        -- ^ Whether to invert the
                                                 -- selection (deselect tags
                                                 -- that meet the comparison)
               , tfFilterOn      :: !FilterOn    -- ^ The memory bank in which
                                                 -- to compare the mask
               , tfBitPointer    :: !Word32      -- ^ The location (in bits) at
                                                 -- which to begin comparing
                                                 -- the mask
               , tfMaskBitLength :: !Word16      -- ^ The length (in bits) of
                                                 -- the mask
               , tfMask          :: !ByteString  -- ^ The mask value to compare
                                                 -- with the specified region
                                                 -- of tag memory, MSB first
               }
               deriving (Eq, Ord, Show, Read)

instance Storable TagFilter where
  sizeOf _ = #{size TagFilterEtc}
  alignment _ = 8

  poke p (TagFilterEPC td) = do
    #{poke TagFilterEtc, filter.type} p
      (#{const TMR_FILTER_TYPE_TAG_DATA} :: #{type TMR_FilterType})
    #{poke TagFilterEtc, filter.u.tagData} p td

  poke p tf@(TagFilterGen2 {}) = do
    #{poke TagFilterEtc, filter.type} p
      (#{const TMR_FILTER_TYPE_GEN2_SELECT} :: #{type TMR_FilterType})
    #{poke TagFilterEtc, filter.u.gen2Select.invert} p (fromBool' $ tfInvert tf)
    #{poke TagFilterEtc, filter.u.gen2Select.bank} p (tfFilterOn tf)
    #{poke TagFilterEtc, filter.u.gen2Select.bitPointer} p (tfBitPointer tf)
    #{poke TagFilterEtc, filter.u.gen2Select.maskBitLength} p (tfMaskBitLength tf)
    let maskLenBytes = fromIntegral $ (tfMaskBitLength tf + 7) `div` 8
        origLen = B.length (tfMask tf)
        bs = if origLen < maskLenBytes
               then tfMask tf <> B.pack (replicate (maskLenBytes - origLen) 0)
               else tfMask tf
    B.useAsCStringLen bs $ \(cs, len) -> do
      len' <- castLen' #{const GLUE_MAX_MASK} "tfMask" len
      copyArray (#{ptr TagFilterEtc, mask} p) cs (fromIntegral len')
    #{poke TagFilterEtc, filter.u.gen2Select.mask} p (#{ptr TagFilterEtc, mask} p)

  peek p = do
    ft <- #{peek TagFilterEtc, filter.type} p :: IO #{type TMR_FilterType}
    case ft of
      #{const TMR_FILTER_TYPE_TAG_DATA} ->
        TagFilterEPC <$> #{peek TagFilterEtc, filter.u.tagData} p
      #{const TMR_FILTER_TYPE_GEN2_SELECT} ->
        TagFilterGen2
        <$> (toBool' <$> #{peek TagFilterEtc, filter.u.gen2Select.invert} p)
        <*> #{peek TagFilterEtc, filter.u.gen2Select.bank} p
        <*> #{peek TagFilterEtc, filter.u.gen2Select.bitPointer} p
        <*> #{peek TagFilterEtc, filter.u.gen2Select.maskBitLength} p
        <*> peekMask p

peekMask :: Ptr TagFilter -> IO ByteString
peekMask p = do
  bitLength <- #{peek TagFilterEtc, filter.u.gen2Select.maskBitLength} p :: IO Word32
  let len = fromIntegral $ (bitLength + 7) `div` 8
  maskPtr <- #{peek TagFilterEtc, filter.u.gen2Select.mask} p
  B.packCStringLen (maskPtr, len)

packBits :: Num b => (a -> b) -> [a] -> b
packBits from flags = sum $ map from flags

unpackBits :: (Bounded a, Enum a, Num b, Bits b) => (a -> b) -> b -> [a]
unpackBits from x = mapMaybe f [minBound..maxBound]
  where f flag = if (x .&. from flag) == 0
                 then Nothing
                 else Just flag

packFlags :: [MetadataFlag] -> RawMetadataFlag
packFlags = packBits fromMetadataFlag

unpackFlags :: RawMetadataFlag -> [MetadataFlag]
unpackFlags = unpackBits fromMetadataFlag

packFlags16 :: [MetadataFlag] -> Word16
packFlags16 = fromIntegral . packFlags

unpackFlags16 :: Word16 -> [MetadataFlag]
unpackFlags16 = unpackFlags . fromIntegral

packExtraBanks :: [GEN2_Bank] -> RawBank
packExtraBanks = packBits fromExtraBank

unpackExtraBanks :: RawBank -> [GEN2_Bank]
unpackExtraBanks = unpackBits fromExtraBank

packLockBits :: [GEN2_LockBits] -> RawLockBits
packLockBits = packBits fromLockBits

unpackLockBits :: RawLockBits -> [GEN2_LockBits]
unpackLockBits = unpackBits fromLockBits

packLockBits16 :: [GEN2_LockBits] -> Word16
packLockBits16 = fromIntegral . packLockBits

unpackLockBits16 :: Word16 -> [GEN2_LockBits]
unpackLockBits16 = unpackLockBits . fromIntegral

peekArrayAsByteString :: Ptr Word8 -> Ptr Word8 -> IO ByteString
peekArrayAsByteString arrayPtr lenPtr = do
  len <- peek lenPtr
  B.packCStringLen (castPtr arrayPtr, fromIntegral len)

pokeArrayAsByteString :: Text
                      -> Word8
                      -> Ptr Word8
                      -> Ptr Word8
                      -> ByteString
                      -> IO ()
pokeArrayAsByteString desc maxLen arrayPtr lenPtr bs = do
  B.useAsCStringLen bs $ \(cs, len) -> do
    len' <- castLen' maxLen desc len
    copyArray arrayPtr (castPtr cs) (fromIntegral len')
    poke lenPtr len'

peekListAsByteString :: Ptr List16 -> IO ByteString
peekListAsByteString listPtr = do
  lst <- peek listPtr
  B.packCStringLen (castPtr $ l16_list lst, fromIntegral $ l16_len lst)

peekArrayAsList :: Storable a => Ptr a -> Ptr Word8 -> IO [a]
peekArrayAsList arrayPtr lenPtr = do
  len <- peek lenPtr
  peekArray (fromIntegral len) arrayPtr

peekListAsList :: Storable a => Ptr List16 -> Ptr a -> IO [a]
peekListAsList listPtr _ = do
  lst <- peek listPtr
  peekArray (fromIntegral $ l16_len lst) (castPtr $ l16_list lst)

pokeListAsList :: Storable a
               => Text
               -> Word16
               -> Ptr List16
               -> Ptr a
               -> [a]
               -> IO ()
pokeListAsList desc maxLen listPtr storage xs = do
  withArrayLen xs $ \len tmpPtr -> do
    len' <- castLen' maxLen desc len
    copyArray storage tmpPtr len
    let lst = List16
              { l16_list = castPtr storage
              , l16_max = maxLen
              , l16_len = len'
              }
    poke listPtr lst

peekMaybe :: (Storable a, Storable b)
          => (Ptr a -> IO a)
          -> (b -> Bool)
          -> Ptr a
          -> Ptr b
          -> IO (Maybe a)
peekMaybe oldPeek cond justP condP = do
  c <- peek condP
  if cond c
    then Just <$> oldPeek justP
    else return Nothing

pokeGen2TagData :: Ptr GEN2_TagData
                -> Ptr RawTagProtocol
                -> Maybe GEN2_TagData
                -> IO ()
pokeGen2TagData pGen2 _ mGen2 = do
  let gen2 = fromMaybe (GEN2_TagData B.empty) mGen2
  poke pGen2 gen2

peekSplit64 :: Ptr Word32 -> Ptr Word32 -> IO Word64
peekSplit64 pLow pHigh = do
  lo <- fromIntegral <$> peek pLow
  hi <- fromIntegral <$> peek pHigh
  return $ lo .|. (hi `shiftL` 32)

peekPtr :: Storable a => Ptr (Ptr a) -> Ptr a -> IO a
peekPtr pp _ = do
  p <- peek pp
  peek p

pokePtr :: Storable a => Ptr (Ptr a) -> Ptr a -> a -> IO ()
pokePtr pp p x = do
  poke p x
  poke pp p

pokeOr :: (Storable a, Bits a) => Ptr a -> a -> IO ()
pokeOr p x = do
  old <- peek p
  poke p (x .|. old)

-- end of code inserted from util/header.hsc

data List16 =
  List16
  { l16_list :: !(Ptr ())
  , l16_max :: !(Word16)
  , l16_len :: !(Word16)
  }

instance Storable List16 where
  sizeOf _ = #{size List16}
  alignment _ = 8
  peek p = List16
           <$> #{peek List16, list} p
           <*> #{peek List16, max} p
           <*> #{peek List16, len} p
  poke p x = do
    #{poke List16, list} p (l16_list x)
    #{poke List16, max} p (l16_max x)
    #{poke List16, len} p (l16_len x)

getList16 :: Storable a => (Ptr () -> IO ()) -> IO [a]
getList16 f = do
  let maxLen = maxBound :: Word16
  allocaArray (fromIntegral maxLen) $ \storage -> do
    let lst = List16
              { l16_list = castPtr storage
              , l16_max = maxLen
              , l16_len = 0
              }
    with lst $ \p -> do
      f (castPtr p)
      lst' <- peek p
      peekArray (fromIntegral (l16_len lst')) storage

setList16 :: Storable a => Text -> [a] -> (Ptr () -> IO ()) -> IO ()
setList16 t x f = do
  withArrayLen x $ \len storage -> do
    len' <- castLen t len
    let lst = List16
              { l16_list = castPtr storage
              , l16_max = len'
              , l16_len = len'
              }
    with lst $ \p -> f (castPtr p)

pokeList16 :: Storable a => (Ptr List16, Word16, Ptr a, Text) -> [a] -> IO ()
pokeList16 (lp, maxLen, storage, name) ws = do
  len <- castLen' maxLen name (length ws)
  poke lp $ List16
    { l16_list = castPtr storage
    , l16_max = maxLen
    , l16_len = len
    }
  pokeArray storage ws

peekList16 :: Storable a => (Ptr List16, Word16, Ptr a, Text) -> IO [a]
peekList16 (lp, _, _, _) = do
  lst <- peek lp
  peekArray (fromIntegral $ l16_len lst) (castPtr $ l16_list lst)

data List8 =
  List8
  { l8_list :: !(Ptr ())
  , l8_max :: !(Word8)
  , l8_len :: !(Word8)
  }

instance Storable List8 where
  sizeOf _ = #{size List8}
  alignment _ = 8
  peek p = List8
           <$> #{peek List8, list} p
           <*> #{peek List8, max} p
           <*> #{peek List8, len} p
  poke p x = do
    #{poke List8, list} p (l8_list x)
    #{poke List8, max} p (l8_max x)
    #{poke List8, len} p (l8_len x)

getList8 :: Storable a => (Ptr () -> IO ()) -> IO [a]
getList8 f = do
  let maxLen = maxBound :: Word8
  allocaArray (fromIntegral maxLen) $ \storage -> do
    let lst = List8
              { l8_list = castPtr storage
              , l8_max = maxLen
              , l8_len = 0
              }
    with lst $ \p -> do
      f (castPtr p)
      lst' <- peek p
      peekArray (fromIntegral (l8_len lst')) storage

setList8 :: Storable a => Text -> [a] -> (Ptr () -> IO ()) -> IO ()
setList8 t x f = do
  withArrayLen x $ \len storage -> do
    len' <- castLen t len
    let lst = List8
              { l8_list = castPtr storage
              , l8_max = len'
              , l8_len = len'
              }
    with lst $ \p -> f (castPtr p)

pokeList8 :: Storable a => (Ptr List8, Word8, Ptr a, Text) -> [a] -> IO ()
pokeList8 (lp, maxLen, storage, name) ws = do
  len <- castLen' maxLen name (length ws)
  poke lp $ List8
    { l8_list = castPtr storage
    , l8_max = maxLen
    , l8_len = len
    }
  pokeArray storage ws

peekList8 :: Storable a => (Ptr List8, Word8, Ptr a, Text) -> IO [a]
peekList8 (lp, _, _, _) = do
  lst <- peek lp
  peekArray (fromIntegral $ l8_len lst) (castPtr $ l8_list lst)

-- | Gen2-specific per-tag data
newtype GEN2_TagData =
  GEN2_TagData
  { g2Pc :: (ByteString) -- ^ Tag PC
  } deriving (Eq, Ord, Show, Read)

instance Storable GEN2_TagData where
  sizeOf _ = #{size TMR_GEN2_TagData}
  alignment _ = 8

  peek p =
    GEN2_TagData
      <$> (peekArrayAsByteString (#{ptr TMR_GEN2_TagData, pc} p) (#{ptr TMR_GEN2_TagData, pcByteCount} p))

  poke p x = do
    pokeArrayAsByteString "pc" #{const TMR_GEN2_MAX_PC_BYTE_COUNT} (#{ptr TMR_GEN2_TagData, pc} p) (#{ptr TMR_GEN2_TagData, pcByteCount} p) (g2Pc x)

-- | A record to represent RFID tags.
data TagData =
  TagData
  { tdEpc :: !(ByteString) -- ^ Tag EPC
  , tdProtocol :: !(TagProtocol) -- ^ Protocol of the tag
  , tdCrc :: !(Word16) -- ^ Tag CRC
  , tdGen2 :: !(Maybe (GEN2_TagData)) -- ^ Gen2-specific tag information
  } deriving (Eq, Ord, Show, Read)

instance Storable TagData where
  sizeOf _ = #{size TMR_TagData}
  alignment _ = 8

  peek p =
    TagData
      <$> (peekArrayAsByteString (#{ptr TMR_TagData, epc} p) (#{ptr TMR_TagData, epcByteCount} p))
      <*> (toTagProtocol <$> peek (#{ptr TMR_TagData, protocol} p))
      <*> (peek (#{ptr TMR_TagData, crc} p))
      <*> (peekMaybe (peek) (== (#{const TMR_TAG_PROTOCOL_GEN2} :: RawTagProtocol)) (#{ptr TMR_TagData, u.gen2} p) (#{ptr TMR_TagData, protocol} p))

  poke p x = do
    pokeArrayAsByteString "epc" #{const TMR_MAX_EPC_BYTE_COUNT} (#{ptr TMR_TagData, epc} p) (#{ptr TMR_TagData, epcByteCount} p) (tdEpc x)
    poke (#{ptr TMR_TagData, protocol} p) (fromTagProtocol $ tdProtocol x)
    poke (#{ptr TMR_TagData, crc} p) (tdCrc x)
    pokeGen2TagData (#{ptr TMR_TagData, u.gen2} p) (#{ptr TMR_TagData, protocol} p) (tdGen2 x)

-- | The identity and state of a single GPIO pin.
data GpioPin =
  GpioPin
  { gpId :: !(Word8) -- ^ The ID number of the pin.
  , gpHigh :: !(Bool) -- ^ Whether the pin is in the high state.
  , gpOutput :: !(Bool) -- ^ The direction of the pin
  } deriving (Eq, Ord, Show, Read)

instance Storable GpioPin where
  sizeOf _ = #{size TMR_GpioPin}
  alignment _ = 8

  peek p =
    GpioPin
      <$> (peek (#{ptr TMR_GpioPin, id} p))
      <*> (toBool' <$> peek (#{ptr TMR_GpioPin, high} p))
      <*> (toBool' <$> peek (#{ptr TMR_GpioPin, output} p))

  poke p x = do
    poke (#{ptr TMR_GpioPin, id} p) (gpId x)
    poke (#{ptr TMR_GpioPin, high} p) (fromBool' $ gpHigh x)
    poke (#{ptr TMR_GpioPin, output} p) (fromBool' $ gpOutput x)

-- | A record to represent a read of an RFID tag.
-- Provides access to the metadata of the read event,
-- such as the time of the read, the antenna that read the tag,
-- and the number of times the tag was seen by the air protocol.
data TagReadData =
  TagReadData
  { trTag :: !(TagData) -- ^ The tag that was read
  , trMetadataFlags :: !([MetadataFlag]) -- ^ The set of metadata items below that are valid
  , trPhase :: !(Word16) -- ^ Tag response phase
  , trAntenna :: !(AntennaPort) -- ^ Antenna where the tag was read
  , trGpio :: !([GpioPin]) -- ^ State of GPIO pins at the moment of the tag read
  , trReadCount :: !(Word32) -- ^ Number of times the tag was read
  , trRssi :: !(Int32) -- ^ Strength of the signal received from the tag
  , trFrequency :: !(Word32) -- ^ RF carrier frequency the tag was read with
  , trTimestamp :: !(MillisecondsSinceEpoch) -- ^ Absolute time of the read, in milliseconds since 1\/1\/1970 UTC
  , trData :: !(ByteString) -- ^ Data read from the tag
  , trEpcMemData :: !(ByteString) -- ^ Read EPC bank data bytes  (Only if 'GEN2_BANK_EPC' is present in 'opExtraBanks')
  , trTidMemData :: !(ByteString) -- ^ Read TID bank data bytes  (Only if 'GEN2_BANK_TID' is present in 'opExtraBanks')
  , trUserMemData :: !(ByteString) -- ^ Read USER bank data bytes  (Only if 'GEN2_BANK_USER' is present in 'opExtraBanks')
  , trReservedMemData :: !(ByteString) -- ^ Read RESERVED bank data bytes  (Only if 'GEN2_BANK_RESERVED' is present in 'opExtraBanks')
  } deriving (Eq, Ord, Show, Read)

instance Storable TagReadData where
  sizeOf _ = #{size TMR_TagReadData}
  alignment _ = 8

  peek p =
    TagReadData
      <$> (peek (#{ptr TMR_TagReadData, tag} p))
      <*> (unpackFlags16 <$> peek (#{ptr TMR_TagReadData, metadataFlags} p))
      <*> (peek (#{ptr TMR_TagReadData, phase} p))
      <*> (peek (#{ptr TMR_TagReadData, antenna} p))
      <*> (peekArrayAsList (#{ptr TMR_TagReadData, gpio} p) (#{ptr TMR_TagReadData, gpioCount} p))
      <*> (peek (#{ptr TMR_TagReadData, readCount} p))
      <*> (peek (#{ptr TMR_TagReadData, rssi} p))
      <*> (peek (#{ptr TMR_TagReadData, frequency} p))
      <*> (peekSplit64 (#{ptr TMR_TagReadData, timestampLow} p) (#{ptr TMR_TagReadData, timestampHigh} p))
      <*> (peekListAsByteString (#{ptr TMR_TagReadData, data} p))
      <*> (peekListAsByteString (#{ptr TMR_TagReadData, epcMemData} p))
      <*> (peekListAsByteString (#{ptr TMR_TagReadData, tidMemData} p))
      <*> (peekListAsByteString (#{ptr TMR_TagReadData, userMemData} p))
      <*> (peekListAsByteString (#{ptr TMR_TagReadData, reservedMemData} p))

  poke p x = error "poke not implemented for TagReadData"

-- | An operation that can be performed on a tag.  Can be used
-- as an argument to @executeTagOp@, or can be embedded into
-- a read plan.
data TagOp =
    TagOp_GEN2_WriteTag
    { opEpc :: !(TagData) -- ^ Tag EPC
    }
  | TagOp_GEN2_WriteData
    { opBank :: !(GEN2_Bank) -- ^ Gen2 memory bank to write to
    , opWordAddress :: !(Word32) -- ^ Word address to start writing at
    , opData :: !([Word16]) -- ^ Data to write
    }
  | TagOp_GEN2_ReadData
    { opBank :: !(GEN2_Bank) -- ^ Gen2 memory bank to read from
    , opExtraBanks :: !([GEN2_Bank]) -- ^ Additional Gen2 memory banks to read from  (seems buggy, though; I\'ve had strange results with it)
    , opWordAddress :: !(Word32) -- ^ Word address to start reading at
    , opLen :: !(Word8) -- ^ Number of words to read
    }
  | TagOp_GEN2_Lock
    { opMask :: !([GEN2_LockBits]) -- ^ Bitmask indicating which lock bits to change
    , opAction :: !([GEN2_LockBits]) -- ^ New values of each bit specified in the mask
    , opAccessPassword :: !(GEN2_Password) -- ^ Access Password to use to lock the tag
    }
  | TagOp_GEN2_Kill
    { opPassword :: !(GEN2_Password) -- ^ Kill password to use to kill the tag
    }
  deriving (Eq, Ord, Show, Read)

instance Storable TagOp where
  sizeOf _ = #{size TagOpEtc}
  alignment _ = 8

  peek p = do
    x <- #{peek TagOpEtc, tagop.type} p :: IO #{type TMR_TagOpType}
    case x of
      #{const TMR_TAGOP_GEN2_WRITETAG} -> do
        TagOp_GEN2_WriteTag
          <$> (peekPtr (#{ptr TagOpEtc, tagop.u.gen2.u.writeTag.epcptr} p) (#{ptr TagOpEtc, epc} p))
      #{const TMR_TAGOP_GEN2_WRITEDATA} -> do
        TagOp_GEN2_WriteData
          <$> ((toBank . (.&. 3)) <$> peek (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.bank} p))
          <*> (peek (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.wordAddress} p))
          <*> (peekListAsList (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.data} p) (#{ptr TagOpEtc, data16} p))
      #{const TMR_TAGOP_GEN2_READDATA} -> do
        TagOp_GEN2_ReadData
          <$> ((toBank . (.&. 3)) <$> peek (#{ptr TagOpEtc, tagop.u.gen2.u.readData.bank} p))
          <*> (unpackExtraBanks <$> peek (#{ptr TagOpEtc, tagop.u.gen2.u.readData.bank} p))
          <*> (peek (#{ptr TagOpEtc, tagop.u.gen2.u.readData.wordAddress} p))
          <*> (peek (#{ptr TagOpEtc, tagop.u.gen2.u.readData.len} p))
      #{const TMR_TAGOP_GEN2_LOCK} -> do
        TagOp_GEN2_Lock
          <$> (unpackLockBits16 <$> peek (#{ptr TagOpEtc, tagop.u.gen2.u.lock.mask} p))
          <*> (unpackLockBits16 <$> peek (#{ptr TagOpEtc, tagop.u.gen2.u.lock.action} p))
          <*> (peek (#{ptr TagOpEtc, tagop.u.gen2.u.lock.accessPassword} p))
      #{const TMR_TAGOP_GEN2_KILL} -> do
        TagOp_GEN2_Kill
          <$> (peek (#{ptr TagOpEtc, tagop.u.gen2.u.kill.password} p))

  poke p x@(TagOp_GEN2_WriteTag {}) = do
    #{poke TagOpEtc, tagop.type} p (#{const TMR_TAGOP_GEN2_WRITETAG} :: #{type TMR_TagOpType})
    pokePtr (#{ptr TagOpEtc, tagop.u.gen2.u.writeTag.epcptr} p) (#{ptr TagOpEtc, epc} p) (opEpc x)

  poke p x@(TagOp_GEN2_WriteData {}) = do
    #{poke TagOpEtc, tagop.type} p (#{const TMR_TAGOP_GEN2_WRITEDATA} :: #{type TMR_TagOpType})
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.bank} p) (fromBank $ opBank x)
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.wordAddress} p) (opWordAddress x)
    pokeListAsList "data" #{const GLUE_MAX_DATA16} (#{ptr TagOpEtc, tagop.u.gen2.u.writeData.data} p) (#{ptr TagOpEtc, data16} p) (opData x)

  poke p x@(TagOp_GEN2_ReadData {}) = do
    #{poke TagOpEtc, tagop.type} p (#{const TMR_TAGOP_GEN2_READDATA} :: #{type TMR_TagOpType})
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.readData.bank} p) (fromBank $ opBank x)
    pokeOr (#{ptr TagOpEtc, tagop.u.gen2.u.readData.bank} p) (packExtraBanks $ opExtraBanks x)
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.readData.wordAddress} p) (opWordAddress x)
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.readData.len} p) (opLen x)

  poke p x@(TagOp_GEN2_Lock {}) = do
    #{poke TagOpEtc, tagop.type} p (#{const TMR_TAGOP_GEN2_LOCK} :: #{type TMR_TagOpType})
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.lock.mask} p) (packLockBits16 $ opMask x)
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.lock.action} p) (packLockBits16 $ opAction x)
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.lock.accessPassword} p) (opAccessPassword x)

  poke p x@(TagOp_GEN2_Kill {}) = do
    #{poke TagOpEtc, tagop.type} p (#{const TMR_TAGOP_GEN2_KILL} :: #{type TMR_TagOpType})
    poke (#{ptr TagOpEtc, tagop.u.gen2.u.kill.password} p) (opPassword x)

-- | Indicates a general category of error.
data StatusType =
    SUCCESS_TYPE
  | ERROR_TYPE_COMM
  | ERROR_TYPE_CODE
  | ERROR_TYPE_MISC
  | ERROR_TYPE_LLRP
  | ERROR_TYPE_BINDING -- ^ An error which originates from the Haskell binding, not the underlying C library.
  | ERROR_TYPE_UNKNOWN -- ^ Not a recognized status type
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

toStatusType :: Word32 -> StatusType
toStatusType #{const TMR_SUCCESS_TYPE} = SUCCESS_TYPE
toStatusType #{const TMR_ERROR_TYPE_COMM} = ERROR_TYPE_COMM
toStatusType #{const TMR_ERROR_TYPE_CODE} = ERROR_TYPE_CODE
toStatusType #{const TMR_ERROR_TYPE_MISC} = ERROR_TYPE_MISC
toStatusType #{const TMR_ERROR_TYPE_LLRP} = ERROR_TYPE_LLRP
toStatusType #{const ERROR_TYPE_BINDING} = ERROR_TYPE_BINDING
toStatusType _ = ERROR_TYPE_UNKNOWN

-- | A specific error encountered by the C API or the Haskell binding.
data Status =
    SUCCESS -- ^ Success!  (Never thrown in an exception)
  | ERROR_MSG_WRONG_NUMBER_OF_DATA -- ^ Invalid number of arguments
  | ERROR_INVALID_OPCODE -- ^ Command opcode not recognized.
  | ERROR_UNIMPLEMENTED_OPCODE -- ^ Command opcode recognized, but is not supported.
  | ERROR_MSG_POWER_TOO_HIGH -- ^ Requested power setting is above the allowed maximum.
  | ERROR_MSG_INVALID_FREQ_RECEIVED -- ^ Requested frequency is outside the allowed range.
  | ERROR_MSG_INVALID_PARAMETER_VALUE -- ^ Parameter value is outside the allowed range.
  | ERROR_MSG_POWER_TOO_LOW -- ^ Requested power setting is below the allowed minimum.
  | ERROR_UNIMPLEMENTED_FEATURE -- ^ Command not supported.
  | ERROR_INVALID_BAUD_RATE -- ^ Requested serial speed is not supported.
  | ERROR_INVALID_REGION -- ^ Region is not supported.
  | ERROR_INVALID_LICENSE_KEY -- ^  License key code is invalid
  | ERROR_BL_INVALID_IMAGE_CRC -- ^ Firmware is corrupt: Checksum doesn\'t match content.
  | ERROR_BL_INVALID_APP_END_ADDR -- ^ Serial protocol status code for this exception.
  | ERROR_FLASH_BAD_ERASE_PASSWORD -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_BAD_WRITE_PASSWORD -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_UNDEFINED_SECTOR -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_ILLEGAL_SECTOR -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_WRITE_TO_NON_ERASED_AREA -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_WRITE_TO_ILLEGAL_SECTOR -- ^ Internal reader error.  Contact support.
  | ERROR_FLASH_VERIFY_FAILED -- ^ Internal reader error.  Contact support.
  | ERROR_NO_TAGS_FOUND -- ^ Reader was asked to find tags, but none were detected.
  | ERROR_NO_PROTOCOL_DEFINED -- ^ RFID protocol has not been configured.
  | ERROR_INVALID_PROTOCOL_SPECIFIED -- ^ Requested RFID protocol is not recognized.
  | ERROR_WRITE_PASSED_LOCK_FAILED -- ^ Lock failed after write operation
  | ERROR_PROTOCOL_NO_DATA_READ -- ^ Tag data was requested, but could not be read.
  | ERROR_AFE_NOT_ON -- ^ AFE not on - reader not sufficiently configured
  | ERROR_PROTOCOL_WRITE_FAILED -- ^ Write to tag failed.
  | ERROR_NOT_IMPLEMENTED_FOR_THIS_PROTOCOL -- ^ Command is not supported in the current RFID protocol.
  | ERROR_PROTOCOL_INVALID_WRITE_DATA -- ^ Data does not conform to protocol standards.
  | ERROR_PROTOCOL_INVALID_ADDRESS -- ^ Requested data address is outside the valid range.
  | ERROR_GENERAL_TAG_ERROR -- ^ Unknown error during RFID operation.
  | ERROR_DATA_TOO_LARGE -- ^ Read Tag Data was asked for more data than it supports.
  | ERROR_PROTOCOL_INVALID_KILL_PASSWORD -- ^ Incorrect password was provided to Kill Tag.
  | ERROR_PROTOCOL_KILL_FAILED -- ^ Kill failed for unknown reason.
  | ERROR_PROTOCOL_BIT_DECODING_FAILED -- ^ Internal reader error.  Contact support.
  | ERROR_PROTOCOL_INVALID_EPC -- ^ Internal reader error.  Contact support.
  | ERROR_PROTOCOL_INVALID_NUM_DATA -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_OTHER_ERROR -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_MEMORY_OVERRUN_BAD_PC -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_MEMORY_LOCKED -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_V2_AUTHEN_FAILED -- ^ Authentication failed with specified key.
  | ERROR_GEN2_PROTOCOL_V2_UNTRACE_FAILED -- ^  Untrace operation failed.
  | ERROR_GEN2_PROTOCOL_INSUFFICIENT_POWER -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_NON_SPECIFIC_ERROR -- ^ Internal reader error.  Contact support.
  | ERROR_GEN2_PROTOCOL_UNKNOWN_ERROR -- ^ Internal reader error.  Contact support.
  | ERROR_AHAL_INVALID_FREQ -- ^ A command was received to set a frequency outside the specified range.
  | ERROR_AHAL_CHANNEL_OCCUPIED -- ^ With LBT enabled an attempt was made to set the frequency to an occupied channel.
  | ERROR_AHAL_TRANSMITTER_ON -- ^ Checking antenna status while CW is on is not allowed.
  | ERROR_ANTENNA_NOT_CONNECTED -- ^  Antenna not detected during pre-transmit safety test.
  | ERROR_TEMPERATURE_EXCEED_LIMITS -- ^ Reader temperature outside safe range.
  | ERROR_HIGH_RETURN_LOSS -- ^  Excess power detected at transmitter port, usually due to antenna tuning mismatch.
  | ERROR_INVALID_ANTENNA_CONFIG -- ^ Invalid antenna configuration
  | ERROR_TAG_ID_BUFFER_NOT_ENOUGH_TAGS_AVAILABLE -- ^ Asked for more tags than were available in the buffer.
  | ERROR_TAG_ID_BUFFER_FULL -- ^ Too many tags are in buffer.  Remove some with Get Tag ID Buffer or Clear Tag ID Buffer.
  | ERROR_TAG_ID_BUFFER_REPEATED_TAG_ID -- ^ Internal error -- reader is trying to insert a duplicate tag record.  Contact support.
  | ERROR_TAG_ID_BUFFER_NUM_TAG_TOO_LARGE -- ^ Asked for tags than a single transaction can handle.
  | ERROR_TAG_ID_BUFFER_AUTH_REQUEST -- ^ Blocked response to get additional data from host.
  | ERROR_SYSTEM_UNKNOWN_ERROR -- ^ Internal reader error.  Contact support.
  | ERROR_TM_ASSERT_FAILED -- ^ Internal reader error.  Contact support.
  | ERROR_TIMEOUT -- ^ Timeout
  | ERROR_NO_HOST -- ^ No matching host found
  | ERROR_LLRP -- ^ LLRP error
  | ERROR_PARSE -- ^ Error parsing device response
  | ERROR_DEVICE_RESET -- ^ Device was reset externally
  | ERROR_CRC_ERROR -- ^ CRC Error
  | ERROR_INVALID -- ^ Invalid argument
  | ERROR_UNIMPLEMENTED -- ^ Unimplemented operation
  | ERROR_UNSUPPORTED -- ^ Unsupported operation
  | ERROR_NO_ANTENNA -- ^ No antenna or invalid antenna
  | ERROR_READONLY -- ^ Value is read-only
  | ERROR_TOO_BIG -- ^ Value too big
  | ERROR_NO_THREADS -- ^ Thread initialization failed
  | ERROR_NO_TAGS -- ^ No tags to be retrieved
  | ERROR_NOT_FOUND -- ^ Key not found
  | ERROR_FIRMWARE_FORMAT -- ^ Size or format of firmware image is incorrect
  | ERROR_TRYAGAIN -- ^ Temporary error, try again
  | ERROR_OUT_OF_MEMORY -- ^ Out of memory
  | ERROR_INVALID_WRITE_MODE -- ^ Invalid write mode
  | ERROR_ILLEGAL_VALUE -- ^ Illegal value
  | ERROR_END_OF_READING
  | ERROR_UNSUPPORTED_READER_TYPE -- ^ Unsupported reader type
  | ERROR_BUFFER_OVERFLOW -- ^ Buffer overflow
  | ERROR_LOADSAVE_CONFIG
  | ERROR_AUTOREAD_ENABLED -- ^ Autonomous mode is enabled on reader. Please disable it
  | ERROR_FIRMWARE_UPDATE_ON_AUTOREAD -- ^ Firmware update is successful. Autonomous mode is already enabled on reader
  | ERROR_TIMESTAMP_NULL -- ^ Timestamp cannot be null
  | ERROR_LLRP_GETTYPEREGISTRY -- ^ LLRP Reader GetTypeRegistry Failed
  | ERROR_LLRP_CONNECTIONFAILED -- ^ LLRP Reader Connection attempt is failed
  | ERROR_LLRP_SENDIO_ERROR -- ^ LLRP Reader Send Messages failed
  | ERROR_LLRP_RECEIVEIO_ERROR -- ^ LLRP Reader Receive Messages failed
  | ERROR_LLRP_RECEIVE_TIMEOUT -- ^ LLRP Reader Receive Messages Timeout
  | ERROR_LLRP_MSG_PARSE_ERROR -- ^ Error parsing LLRP message
  | ERROR_LLRP_ALREADY_CONNECTED -- ^ Already connected to reader
  | ERROR_LLRP_INVALID_RFMODE -- ^ Specified RF Mode operation is not supported
  | ERROR_LLRP_UNDEFINED_VALUE -- ^ Undefined Value
  | ERROR_LLRP_READER_ERROR -- ^ LLRP reader unknown error
  | ERROR_LLRP_READER_CONNECTION_LOST -- ^ LLRP reader connection lost
  | ERROR_ALREADY_DESTROYED -- ^ Attempt to use reader after it was destroyed.
  | ERROR_INVALID_PARAM_TYPE -- ^ The parameter value was not of the type expected.
  | ERROR_UNIMPLEMENTED_PARAM -- ^ The given parameter is not yet implemented in the Haskell binding.
  | ERROR_UNKNOWN Word32 -- ^ C API returned an unrecognized status code
  deriving (Eq, Ord, Show, Read)

toStatus :: Word32 -> Status
toStatus #{const TMR_SUCCESS} = SUCCESS
toStatus #{const TMR_ERROR_MSG_WRONG_NUMBER_OF_DATA} = ERROR_MSG_WRONG_NUMBER_OF_DATA
toStatus #{const TMR_ERROR_INVALID_OPCODE} = ERROR_INVALID_OPCODE
toStatus #{const TMR_ERROR_UNIMPLEMENTED_OPCODE} = ERROR_UNIMPLEMENTED_OPCODE
toStatus #{const TMR_ERROR_MSG_POWER_TOO_HIGH} = ERROR_MSG_POWER_TOO_HIGH
toStatus #{const TMR_ERROR_MSG_INVALID_FREQ_RECEIVED} = ERROR_MSG_INVALID_FREQ_RECEIVED
toStatus #{const TMR_ERROR_MSG_INVALID_PARAMETER_VALUE} = ERROR_MSG_INVALID_PARAMETER_VALUE
toStatus #{const TMR_ERROR_MSG_POWER_TOO_LOW} = ERROR_MSG_POWER_TOO_LOW
toStatus #{const TMR_ERROR_UNIMPLEMENTED_FEATURE} = ERROR_UNIMPLEMENTED_FEATURE
toStatus #{const TMR_ERROR_INVALID_BAUD_RATE} = ERROR_INVALID_BAUD_RATE
toStatus #{const TMR_ERROR_INVALID_REGION} = ERROR_INVALID_REGION
toStatus #{const TMR_ERROR_INVALID_LICENSE_KEY} = ERROR_INVALID_LICENSE_KEY
toStatus #{const TMR_ERROR_BL_INVALID_IMAGE_CRC} = ERROR_BL_INVALID_IMAGE_CRC
toStatus #{const TMR_ERROR_BL_INVALID_APP_END_ADDR} = ERROR_BL_INVALID_APP_END_ADDR
toStatus #{const TMR_ERROR_FLASH_BAD_ERASE_PASSWORD} = ERROR_FLASH_BAD_ERASE_PASSWORD
toStatus #{const TMR_ERROR_FLASH_BAD_WRITE_PASSWORD} = ERROR_FLASH_BAD_WRITE_PASSWORD
toStatus #{const TMR_ERROR_FLASH_UNDEFINED_SECTOR} = ERROR_FLASH_UNDEFINED_SECTOR
toStatus #{const TMR_ERROR_FLASH_ILLEGAL_SECTOR} = ERROR_FLASH_ILLEGAL_SECTOR
toStatus #{const TMR_ERROR_FLASH_WRITE_TO_NON_ERASED_AREA} = ERROR_FLASH_WRITE_TO_NON_ERASED_AREA
toStatus #{const TMR_ERROR_FLASH_WRITE_TO_ILLEGAL_SECTOR} = ERROR_FLASH_WRITE_TO_ILLEGAL_SECTOR
toStatus #{const TMR_ERROR_FLASH_VERIFY_FAILED} = ERROR_FLASH_VERIFY_FAILED
toStatus #{const TMR_ERROR_NO_TAGS_FOUND} = ERROR_NO_TAGS_FOUND
toStatus #{const TMR_ERROR_NO_PROTOCOL_DEFINED} = ERROR_NO_PROTOCOL_DEFINED
toStatus #{const TMR_ERROR_INVALID_PROTOCOL_SPECIFIED} = ERROR_INVALID_PROTOCOL_SPECIFIED
toStatus #{const TMR_ERROR_WRITE_PASSED_LOCK_FAILED} = ERROR_WRITE_PASSED_LOCK_FAILED
toStatus #{const TMR_ERROR_PROTOCOL_NO_DATA_READ} = ERROR_PROTOCOL_NO_DATA_READ
toStatus #{const TMR_ERROR_AFE_NOT_ON} = ERROR_AFE_NOT_ON
toStatus #{const TMR_ERROR_PROTOCOL_WRITE_FAILED} = ERROR_PROTOCOL_WRITE_FAILED
toStatus #{const TMR_ERROR_NOT_IMPLEMENTED_FOR_THIS_PROTOCOL} = ERROR_NOT_IMPLEMENTED_FOR_THIS_PROTOCOL
toStatus #{const TMR_ERROR_PROTOCOL_INVALID_WRITE_DATA} = ERROR_PROTOCOL_INVALID_WRITE_DATA
toStatus #{const TMR_ERROR_PROTOCOL_INVALID_ADDRESS} = ERROR_PROTOCOL_INVALID_ADDRESS
toStatus #{const TMR_ERROR_GENERAL_TAG_ERROR} = ERROR_GENERAL_TAG_ERROR
toStatus #{const TMR_ERROR_DATA_TOO_LARGE} = ERROR_DATA_TOO_LARGE
toStatus #{const TMR_ERROR_PROTOCOL_INVALID_KILL_PASSWORD} = ERROR_PROTOCOL_INVALID_KILL_PASSWORD
toStatus #{const TMR_ERROR_PROTOCOL_KILL_FAILED} = ERROR_PROTOCOL_KILL_FAILED
toStatus #{const TMR_ERROR_PROTOCOL_BIT_DECODING_FAILED} = ERROR_PROTOCOL_BIT_DECODING_FAILED
toStatus #{const TMR_ERROR_PROTOCOL_INVALID_EPC} = ERROR_PROTOCOL_INVALID_EPC
toStatus #{const TMR_ERROR_PROTOCOL_INVALID_NUM_DATA} = ERROR_PROTOCOL_INVALID_NUM_DATA
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_OTHER_ERROR} = ERROR_GEN2_PROTOCOL_OTHER_ERROR
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_MEMORY_OVERRUN_BAD_PC} = ERROR_GEN2_PROTOCOL_MEMORY_OVERRUN_BAD_PC
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_MEMORY_LOCKED} = ERROR_GEN2_PROTOCOL_MEMORY_LOCKED
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_V2_AUTHEN_FAILED} = ERROR_GEN2_PROTOCOL_V2_AUTHEN_FAILED
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_V2_UNTRACE_FAILED} = ERROR_GEN2_PROTOCOL_V2_UNTRACE_FAILED
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_INSUFFICIENT_POWER} = ERROR_GEN2_PROTOCOL_INSUFFICIENT_POWER
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_NON_SPECIFIC_ERROR} = ERROR_GEN2_PROTOCOL_NON_SPECIFIC_ERROR
toStatus #{const TMR_ERROR_GEN2_PROTOCOL_UNKNOWN_ERROR} = ERROR_GEN2_PROTOCOL_UNKNOWN_ERROR
toStatus #{const TMR_ERROR_AHAL_INVALID_FREQ} = ERROR_AHAL_INVALID_FREQ
toStatus #{const TMR_ERROR_AHAL_CHANNEL_OCCUPIED} = ERROR_AHAL_CHANNEL_OCCUPIED
toStatus #{const TMR_ERROR_AHAL_TRANSMITTER_ON} = ERROR_AHAL_TRANSMITTER_ON
toStatus #{const TMR_ERROR_ANTENNA_NOT_CONNECTED} = ERROR_ANTENNA_NOT_CONNECTED
toStatus #{const TMR_ERROR_TEMPERATURE_EXCEED_LIMITS} = ERROR_TEMPERATURE_EXCEED_LIMITS
toStatus #{const TMR_ERROR_HIGH_RETURN_LOSS} = ERROR_HIGH_RETURN_LOSS
toStatus #{const TMR_ERROR_INVALID_ANTENNA_CONFIG} = ERROR_INVALID_ANTENNA_CONFIG
toStatus #{const TMR_ERROR_TAG_ID_BUFFER_NOT_ENOUGH_TAGS_AVAILABLE} = ERROR_TAG_ID_BUFFER_NOT_ENOUGH_TAGS_AVAILABLE
toStatus #{const TMR_ERROR_TAG_ID_BUFFER_FULL} = ERROR_TAG_ID_BUFFER_FULL
toStatus #{const TMR_ERROR_TAG_ID_BUFFER_REPEATED_TAG_ID} = ERROR_TAG_ID_BUFFER_REPEATED_TAG_ID
toStatus #{const TMR_ERROR_TAG_ID_BUFFER_NUM_TAG_TOO_LARGE} = ERROR_TAG_ID_BUFFER_NUM_TAG_TOO_LARGE
toStatus #{const TMR_ERROR_TAG_ID_BUFFER_AUTH_REQUEST} = ERROR_TAG_ID_BUFFER_AUTH_REQUEST
toStatus #{const TMR_ERROR_SYSTEM_UNKNOWN_ERROR} = ERROR_SYSTEM_UNKNOWN_ERROR
toStatus #{const TMR_ERROR_TM_ASSERT_FAILED} = ERROR_TM_ASSERT_FAILED
toStatus #{const TMR_ERROR_TIMEOUT} = ERROR_TIMEOUT
toStatus #{const TMR_ERROR_NO_HOST} = ERROR_NO_HOST
toStatus #{const TMR_ERROR_LLRP} = ERROR_LLRP
toStatus #{const TMR_ERROR_PARSE} = ERROR_PARSE
toStatus #{const TMR_ERROR_DEVICE_RESET} = ERROR_DEVICE_RESET
toStatus #{const TMR_ERROR_CRC_ERROR} = ERROR_CRC_ERROR
toStatus #{const TMR_ERROR_INVALID} = ERROR_INVALID
toStatus #{const TMR_ERROR_UNIMPLEMENTED} = ERROR_UNIMPLEMENTED
toStatus #{const TMR_ERROR_UNSUPPORTED} = ERROR_UNSUPPORTED
toStatus #{const TMR_ERROR_NO_ANTENNA} = ERROR_NO_ANTENNA
toStatus #{const TMR_ERROR_READONLY} = ERROR_READONLY
toStatus #{const TMR_ERROR_TOO_BIG} = ERROR_TOO_BIG
toStatus #{const TMR_ERROR_NO_THREADS} = ERROR_NO_THREADS
toStatus #{const TMR_ERROR_NO_TAGS} = ERROR_NO_TAGS
toStatus #{const TMR_ERROR_NOT_FOUND} = ERROR_NOT_FOUND
toStatus #{const TMR_ERROR_FIRMWARE_FORMAT} = ERROR_FIRMWARE_FORMAT
toStatus #{const TMR_ERROR_TRYAGAIN} = ERROR_TRYAGAIN
toStatus #{const TMR_ERROR_OUT_OF_MEMORY} = ERROR_OUT_OF_MEMORY
toStatus #{const TMR_ERROR_INVALID_WRITE_MODE} = ERROR_INVALID_WRITE_MODE
toStatus #{const TMR_ERROR_ILLEGAL_VALUE} = ERROR_ILLEGAL_VALUE
toStatus #{const TMR_ERROR_END_OF_READING} = ERROR_END_OF_READING
toStatus #{const TMR_ERROR_UNSUPPORTED_READER_TYPE} = ERROR_UNSUPPORTED_READER_TYPE
toStatus #{const TMR_ERROR_BUFFER_OVERFLOW} = ERROR_BUFFER_OVERFLOW
toStatus #{const TMR_ERROR_LOADSAVE_CONFIG} = ERROR_LOADSAVE_CONFIG
toStatus #{const TMR_ERROR_AUTOREAD_ENABLED} = ERROR_AUTOREAD_ENABLED
toStatus #{const TMR_ERROR_FIRMWARE_UPDATE_ON_AUTOREAD} = ERROR_FIRMWARE_UPDATE_ON_AUTOREAD
toStatus #{const TMR_ERROR_TIMESTAMP_NULL} = ERROR_TIMESTAMP_NULL
toStatus #{const TMR_ERROR_LLRP_GETTYPEREGISTRY} = ERROR_LLRP_GETTYPEREGISTRY
toStatus #{const TMR_ERROR_LLRP_CONNECTIONFAILED} = ERROR_LLRP_CONNECTIONFAILED
toStatus #{const TMR_ERROR_LLRP_SENDIO_ERROR} = ERROR_LLRP_SENDIO_ERROR
toStatus #{const TMR_ERROR_LLRP_RECEIVEIO_ERROR} = ERROR_LLRP_RECEIVEIO_ERROR
toStatus #{const TMR_ERROR_LLRP_RECEIVE_TIMEOUT} = ERROR_LLRP_RECEIVE_TIMEOUT
toStatus #{const TMR_ERROR_LLRP_MSG_PARSE_ERROR} = ERROR_LLRP_MSG_PARSE_ERROR
toStatus #{const TMR_ERROR_LLRP_ALREADY_CONNECTED} = ERROR_LLRP_ALREADY_CONNECTED
toStatus #{const TMR_ERROR_LLRP_INVALID_RFMODE} = ERROR_LLRP_INVALID_RFMODE
toStatus #{const TMR_ERROR_LLRP_UNDEFINED_VALUE} = ERROR_LLRP_UNDEFINED_VALUE
toStatus #{const TMR_ERROR_LLRP_READER_ERROR} = ERROR_LLRP_READER_ERROR
toStatus #{const TMR_ERROR_LLRP_READER_CONNECTION_LOST} = ERROR_LLRP_READER_CONNECTION_LOST
toStatus #{const ERROR_ALREADY_DESTROYED} = ERROR_ALREADY_DESTROYED
toStatus x = ERROR_UNKNOWN x

type RawRegion = #{type TMR_Region}

-- | RFID regulatory regions
data Region =
    REGION_NONE -- ^ Unspecified region
  | REGION_NA -- ^ North America
  | REGION_EU -- ^ European Union
  | REGION_KR -- ^ Korea
  | REGION_IN -- ^ India
  | REGION_JP -- ^ Japan
  | REGION_PRC -- ^ People\'s Republic of China
  | REGION_EU2 -- ^ European Union 2
  | REGION_EU3 -- ^ European Union 3
  | REGION_KR2 -- ^ Korea 2
  | REGION_PRC2 -- ^ People\'s Republic of China(840MHZ)
  | REGION_AU -- ^ Australia
  | REGION_NZ -- ^ New Zealand !!EXPERIMENTAL!!
  | REGION_NA2 -- ^ Reduced FCC region
  | REGION_NA3 -- ^ 5MHZ FCC band
  | REGION_IS -- ^ Israel
  | REGION_OPEN -- ^ Open
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

toRegion :: RawRegion -> Region
toRegion #{const TMR_REGION_NONE} = REGION_NONE
toRegion #{const TMR_REGION_NA} = REGION_NA
toRegion #{const TMR_REGION_EU} = REGION_EU
toRegion #{const TMR_REGION_KR} = REGION_KR
toRegion #{const TMR_REGION_IN} = REGION_IN
toRegion #{const TMR_REGION_JP} = REGION_JP
toRegion #{const TMR_REGION_PRC} = REGION_PRC
toRegion #{const TMR_REGION_EU2} = REGION_EU2
toRegion #{const TMR_REGION_EU3} = REGION_EU3
toRegion #{const TMR_REGION_KR2} = REGION_KR2
toRegion #{const TMR_REGION_PRC2} = REGION_PRC2
toRegion #{const TMR_REGION_AU} = REGION_AU
toRegion #{const TMR_REGION_NZ} = REGION_NZ
toRegion #{const TMR_REGION_NA2} = REGION_NA2
toRegion #{const TMR_REGION_NA3} = REGION_NA3
toRegion #{const TMR_REGION_IS} = REGION_IS
toRegion #{const TMR_REGION_OPEN} = REGION_OPEN
toRegion _ = REGION_NONE

fromRegion :: Region -> RawRegion
fromRegion REGION_NONE = #{const TMR_REGION_NONE}
fromRegion REGION_NA = #{const TMR_REGION_NA}
fromRegion REGION_EU = #{const TMR_REGION_EU}
fromRegion REGION_KR = #{const TMR_REGION_KR}
fromRegion REGION_IN = #{const TMR_REGION_IN}
fromRegion REGION_JP = #{const TMR_REGION_JP}
fromRegion REGION_PRC = #{const TMR_REGION_PRC}
fromRegion REGION_EU2 = #{const TMR_REGION_EU2}
fromRegion REGION_EU3 = #{const TMR_REGION_EU3}
fromRegion REGION_KR2 = #{const TMR_REGION_KR2}
fromRegion REGION_PRC2 = #{const TMR_REGION_PRC2}
fromRegion REGION_AU = #{const TMR_REGION_AU}
fromRegion REGION_NZ = #{const TMR_REGION_NZ}
fromRegion REGION_NA2 = #{const TMR_REGION_NA2}
fromRegion REGION_NA3 = #{const TMR_REGION_NA3}
fromRegion REGION_IS = #{const TMR_REGION_IS}
fromRegion REGION_OPEN = #{const TMR_REGION_OPEN}

-- | A description of the given region, useful for a user interface.
displayRegionDescription :: Region -> Text
displayRegionDescription REGION_NONE = "Unspecified region"
displayRegionDescription REGION_NA = "North America"
displayRegionDescription REGION_EU = "European Union"
displayRegionDescription REGION_KR = "Korea"
displayRegionDescription REGION_IN = "India"
displayRegionDescription REGION_JP = "Japan"
displayRegionDescription REGION_PRC = "People's Republic of China"
displayRegionDescription REGION_EU2 = "European Union 2"
displayRegionDescription REGION_EU3 = "European Union 3"
displayRegionDescription REGION_KR2 = "Korea 2"
displayRegionDescription REGION_PRC2 = "People's Republic of China(840MHZ)"
displayRegionDescription REGION_AU = "Australia"
displayRegionDescription REGION_NZ = "New Zealand !!EXPERIMENTAL!!"
displayRegionDescription REGION_NA2 = "Reduced FCC region"
displayRegionDescription REGION_NA3 = "5MHZ FCC band"
displayRegionDescription REGION_IS = "Israel"
displayRegionDescription REGION_OPEN = "Open"

type RawTagProtocol = #{type TMR_TagProtocol}

-- | The protocol used by an RFID tag.  Only 'TAG_PROTOCOL_GEN2'
-- is supported by the M6e Nano, and therefore the Haskell
-- binding currently only supports that protocol.
data TagProtocol =
    TAG_PROTOCOL_NONE
  | TAG_PROTOCOL_ISO180006B
  | TAG_PROTOCOL_GEN2
  | TAG_PROTOCOL_ISO180006B_UCODE
  | TAG_PROTOCOL_IPX64
  | TAG_PROTOCOL_IPX256
  | TAG_PROTOCOL_ATA
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

toTagProtocol :: RawTagProtocol -> TagProtocol
toTagProtocol #{const TMR_TAG_PROTOCOL_NONE} = TAG_PROTOCOL_NONE
toTagProtocol #{const TMR_TAG_PROTOCOL_ISO180006B} = TAG_PROTOCOL_ISO180006B
toTagProtocol #{const TMR_TAG_PROTOCOL_GEN2} = TAG_PROTOCOL_GEN2
toTagProtocol #{const TMR_TAG_PROTOCOL_ISO180006B_UCODE} = TAG_PROTOCOL_ISO180006B_UCODE
toTagProtocol #{const TMR_TAG_PROTOCOL_IPX64} = TAG_PROTOCOL_IPX64
toTagProtocol #{const TMR_TAG_PROTOCOL_IPX256} = TAG_PROTOCOL_IPX256
toTagProtocol #{const TMR_TAG_PROTOCOL_ATA} = TAG_PROTOCOL_ATA
toTagProtocol _ = TAG_PROTOCOL_NONE

fromTagProtocol :: TagProtocol -> RawTagProtocol
fromTagProtocol TAG_PROTOCOL_NONE = #{const TMR_TAG_PROTOCOL_NONE}
fromTagProtocol TAG_PROTOCOL_ISO180006B = #{const TMR_TAG_PROTOCOL_ISO180006B}
fromTagProtocol TAG_PROTOCOL_GEN2 = #{const TMR_TAG_PROTOCOL_GEN2}
fromTagProtocol TAG_PROTOCOL_ISO180006B_UCODE = #{const TMR_TAG_PROTOCOL_ISO180006B_UCODE}
fromTagProtocol TAG_PROTOCOL_IPX64 = #{const TMR_TAG_PROTOCOL_IPX64}
fromTagProtocol TAG_PROTOCOL_IPX256 = #{const TMR_TAG_PROTOCOL_IPX256}
fromTagProtocol TAG_PROTOCOL_ATA = #{const TMR_TAG_PROTOCOL_ATA}

type RawMetadataFlag = #{type TMR_TRD_MetadataFlag}

-- | Various metadata parameters which can be requested
-- in 'PARAM_METADATAFLAG'.
data MetadataFlag =
    METADATA_FLAG_READCOUNT
  | METADATA_FLAG_RSSI
  | METADATA_FLAG_ANTENNAID
  | METADATA_FLAG_FREQUENCY
  | METADATA_FLAG_TIMESTAMP
  | METADATA_FLAG_PHASE
  | METADATA_FLAG_PROTOCOL
  | METADATA_FLAG_DATA
  | METADATA_FLAG_GPIO_STATUS
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

fromMetadataFlag :: MetadataFlag -> RawMetadataFlag
fromMetadataFlag METADATA_FLAG_READCOUNT = #{const TMR_TRD_METADATA_FLAG_READCOUNT}
fromMetadataFlag METADATA_FLAG_RSSI = #{const TMR_TRD_METADATA_FLAG_RSSI}
fromMetadataFlag METADATA_FLAG_ANTENNAID = #{const TMR_TRD_METADATA_FLAG_ANTENNAID}
fromMetadataFlag METADATA_FLAG_FREQUENCY = #{const TMR_TRD_METADATA_FLAG_FREQUENCY}
fromMetadataFlag METADATA_FLAG_TIMESTAMP = #{const TMR_TRD_METADATA_FLAG_TIMESTAMP}
fromMetadataFlag METADATA_FLAG_PHASE = #{const TMR_TRD_METADATA_FLAG_PHASE}
fromMetadataFlag METADATA_FLAG_PROTOCOL = #{const TMR_TRD_METADATA_FLAG_PROTOCOL}
fromMetadataFlag METADATA_FLAG_DATA = #{const TMR_TRD_METADATA_FLAG_DATA}
fromMetadataFlag METADATA_FLAG_GPIO_STATUS = #{const TMR_TRD_METADATA_FLAG_GPIO_STATUS}

type RawBank = #{type TMR_GEN2_Bank}

-- | Gen2 memory banks
data GEN2_Bank =
    GEN2_BANK_RESERVED -- ^ Reserved bank (kill and access passwords)
  | GEN2_BANK_EPC -- ^ EPC memory bank
  | GEN2_BANK_TID -- ^ TID memory bank
  | GEN2_BANK_USER -- ^ User memory bank
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

fromBank :: GEN2_Bank -> RawBank
fromBank GEN2_BANK_RESERVED = #{const TMR_GEN2_BANK_RESERVED}
fromBank GEN2_BANK_EPC = #{const TMR_GEN2_BANK_EPC}
fromBank GEN2_BANK_TID = #{const TMR_GEN2_BANK_TID}
fromBank GEN2_BANK_USER = #{const TMR_GEN2_BANK_USER}

toBank :: RawBank -> GEN2_Bank
toBank #{const TMR_GEN2_BANK_RESERVED} = GEN2_BANK_RESERVED
toBank #{const TMR_GEN2_BANK_EPC} = GEN2_BANK_EPC
toBank #{const TMR_GEN2_BANK_TID} = GEN2_BANK_TID
toBank #{const TMR_GEN2_BANK_USER} = GEN2_BANK_USER
toBank x = error $ "didn't expect bank to be " ++ show x

fromExtraBank :: GEN2_Bank -> RawBank
fromExtraBank GEN2_BANK_RESERVED = #{const TMR_GEN2_BANK_RESERVED_ENABLED}
fromExtraBank GEN2_BANK_EPC = #{const TMR_GEN2_BANK_EPC_ENABLED}
fromExtraBank GEN2_BANK_TID = #{const TMR_GEN2_BANK_TID_ENABLED}
fromExtraBank GEN2_BANK_USER = #{const TMR_GEN2_BANK_USER_ENABLED}

type RawLockBits = #{type TMR_GEN2_LockBits}

-- | Memory lock bits
data GEN2_LockBits =
    GEN2_LOCK_BITS_USER_PERM -- ^ User memory bank lock permalock bit
  | GEN2_LOCK_BITS_USER -- ^ User memory bank lock bit
  | GEN2_LOCK_BITS_TID_PERM -- ^ TID memory bank lock permalock bit
  | GEN2_LOCK_BITS_TID -- ^ TID memory bank lock bit
  | GEN2_LOCK_BITS_EPC_PERM -- ^ EPC memory bank lock permalock bit
  | GEN2_LOCK_BITS_EPC -- ^ EPC memory bank lock bit
  | GEN2_LOCK_BITS_ACCESS_PERM -- ^ Access password lock permalock bit
  | GEN2_LOCK_BITS_ACCESS -- ^ Access password lock bit
  | GEN2_LOCK_BITS_KILL_PERM -- ^ Kill password lock permalock bit
  | GEN2_LOCK_BITS_KILL -- ^ Kill password lock bit
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

fromLockBits :: GEN2_LockBits -> RawLockBits
fromLockBits GEN2_LOCK_BITS_USER_PERM = #{const TMR_GEN2_LOCK_BITS_USER_PERM}
fromLockBits GEN2_LOCK_BITS_USER = #{const TMR_GEN2_LOCK_BITS_USER}
fromLockBits GEN2_LOCK_BITS_TID_PERM = #{const TMR_GEN2_LOCK_BITS_TID_PERM}
fromLockBits GEN2_LOCK_BITS_TID = #{const TMR_GEN2_LOCK_BITS_TID}
fromLockBits GEN2_LOCK_BITS_EPC_PERM = #{const TMR_GEN2_LOCK_BITS_EPC_PERM}
fromLockBits GEN2_LOCK_BITS_EPC = #{const TMR_GEN2_LOCK_BITS_EPC}
fromLockBits GEN2_LOCK_BITS_ACCESS_PERM = #{const TMR_GEN2_LOCK_BITS_ACCESS_PERM}
fromLockBits GEN2_LOCK_BITS_ACCESS = #{const TMR_GEN2_LOCK_BITS_ACCESS}
fromLockBits GEN2_LOCK_BITS_KILL_PERM = #{const TMR_GEN2_LOCK_BITS_KILL_PERM}
fromLockBits GEN2_LOCK_BITS_KILL = #{const TMR_GEN2_LOCK_BITS_KILL}

type RawParam = #{type TMR_Param}

-- | Reader parameters which you can get and set.  The names
-- are the same as the names of the enum in the C API.
-- (Unfortunately, these do not correspond to the
-- \"path\"-style names in any systematic way.)
-- Each parameter is listed with its \"path\", and the
-- Haskell type which is used to store it.  Some parameters
-- are also listed with the physical units the parameter
-- is in.  Not all parameters are implemented in the Haskell
-- binding.  Please file a Github issue if there is a parameter
-- you need which is not implemented.
data Param =
    PARAM_NONE -- ^ No such parameter - used as a return value from 'System.Hardware.MercuryApi.paramID'.
  | PARAM_BAUDRATE -- ^ @\/reader\/baudRate@ 'Word32'
  | PARAM_COMMANDTIMEOUT -- ^ @\/reader\/commandTimeout@ 'Word32' (milliseconds)
  | PARAM_CURRENTTIME -- ^ @\/reader\/currentTime@ (Not yet implemented)
  | PARAM_READER_DESCRIPTION -- ^ @\/reader\/description@ 'Text'
  | PARAM_EXTENDEDEPC -- ^ @\/reader\/extendedEpc@ 'Bool'
  | PARAM_READER_HOSTNAME -- ^ @\/reader\/hostname@ 'Text'
  | PARAM_LICENSE_KEY -- ^ @\/reader\/licenseKey@ ['Word8']
  | PARAM_LICENSED_FEATURES -- ^ @\/reader\/licensedFeatures@ ['Word8']
  | PARAM_METADATAFLAG -- ^ @\/reader\/metadataflags@ ['MetadataFlag']
  | PARAM_POWERMODE -- ^ @\/reader\/powerMode@ (Not yet implemented)
  | PARAM_PROBEBAUDRATES -- ^ @\/reader\/probeBaudRates@ ['Word32']
  | PARAM_READER_STATISTICS -- ^ @\/reader\/statistics@ (Not yet implemented)
  | PARAM_READER_STATS -- ^ @\/reader\/stats@ (Not yet implemented)
  | PARAM_TRANSPORTTIMEOUT -- ^ @\/reader\/transportTimeout@ 'Word32' (milliseconds)
  | PARAM_URI -- ^ @\/reader\/uri@ 'Text' (read-only)
  | PARAM_USER_CONFIG -- ^ @\/reader\/userConfig@ (Not yet implemented)
  | PARAM_USERMODE -- ^ @\/reader\/userMode@ (Not yet implemented)
  | PARAM_ANTENNA_CHECKPORT -- ^ @\/reader\/antenna\/checkPort@ 'Bool'
  | PARAM_ANTENNA_CONNECTEDPORTLIST -- ^ @\/reader\/antenna\/connectedPortList@ ['Word8'], or typedef ['AntennaPort'] (read-only)
  | PARAM_ANTENNA_PORTLIST -- ^ @\/reader\/antenna\/portList@ ['Word8'], or typedef ['AntennaPort'] (read-only)
  | PARAM_ANTENNA_PORTSWITCHGPOS -- ^ @\/reader\/antenna\/portSwitchGpos@ ['Word8'], or typedef ['PinNumber']
  | PARAM_ANTENNA_RETURNLOSS -- ^ @\/reader\/antenna\/returnLoss@ (Not yet implemented)
  | PARAM_ANTENNA_SETTLINGTIMELIST -- ^ @\/reader\/antenna\/settlingTimeList@ (Not yet implemented)
  | PARAM_ANTENNA_TXRXMAP -- ^ @\/reader\/antenna\/txRxMap@ (Not yet implemented)
  | PARAM_GEN2_BLF -- ^ @\/reader\/gen2\/BLF@ (Not yet implemented)
  | PARAM_GEN2_ACCESSPASSWORD -- ^ @\/reader\/gen2\/accessPassword@ 'Word32', or typedef 'GEN2_Password'
  | PARAM_GEN2_BAP -- ^ @\/reader\/gen2\/bap@ (Not yet implemented)
  | PARAM_GEN2_PROTOCOLEXTENSION -- ^ @\/reader\/gen2\/protocolExtension@ (Not yet implemented)
  | PARAM_GEN2_Q -- ^ @\/reader\/gen2\/q@ (Not yet implemented)
  | PARAM_GEN2_SESSION -- ^ @\/reader\/gen2\/session@ (Not yet implemented)
  | PARAM_GEN2_TAGENCODING -- ^ @\/reader\/gen2\/tagEncoding@ (Not yet implemented)
  | PARAM_GEN2_TARGET -- ^ @\/reader\/gen2\/target@ (Not yet implemented)
  | PARAM_GEN2_TARI -- ^ @\/reader\/gen2\/tari@ (Not yet implemented)
  | PARAM_READER_WRITE_EARLY_EXIT -- ^ @\/reader\/gen2\/writeEarlyExit@ 'Bool'
  | PARAM_GEN2_WRITEMODE -- ^ @\/reader\/gen2\/writeMode@ (Not yet implemented)
  | PARAM_READER_WRITE_REPLY_TIMEOUT -- ^ @\/reader\/gen2\/writeReplyTimeout@ 'Word16' (microseconds)
  | PARAM_GPIO_INPUTLIST -- ^ @\/reader\/gpio\/inputList@ ['Word8'], or typedef ['PinNumber']
  | PARAM_GPIO_OUTPUTLIST -- ^ @\/reader\/gpio\/outputList@ ['Word8'], or typedef ['PinNumber']
  | PARAM_ISO180006B_BLF -- ^ @\/reader\/iso180006b\/BLF@ (Not yet implemented)
  | PARAM_ISO180006B_DELIMITER -- ^ @\/reader\/iso180006b\/delimiter@ (Not yet implemented)
  | PARAM_ISO180006B_MODULATION_DEPTH -- ^ @\/reader\/iso180006b\/modulationDepth@ (Not yet implemented)
  | PARAM_RADIO_ENABLEPOWERSAVE -- ^ @\/reader\/radio\/enablePowerSave@ 'Bool'
  | PARAM_RADIO_ENABLESJC -- ^ @\/reader\/radio\/enableSJC@ 'Bool'
  | PARAM_RADIO_PORTREADPOWERLIST -- ^ @\/reader\/radio\/portReadPowerList@ (Not yet implemented)
  | PARAM_RADIO_PORTWRITEPOWERLIST -- ^ @\/reader\/radio\/portWritePowerList@ (Not yet implemented)
  | PARAM_RADIO_POWERMAX -- ^ @\/reader\/radio\/powerMax@ 'Int16' (centi-dBm, read-only)
  | PARAM_RADIO_POWERMIN -- ^ @\/reader\/radio\/powerMin@ 'Int16' (centi-dBm, read-only)
  | PARAM_RADIO_READPOWER -- ^ @\/reader\/radio\/readPower@ 'Int32' (centi-dBm)
  | PARAM_RADIO_TEMPERATURE -- ^ @\/reader\/radio\/temperature@ 'Int8' (degrees C, read-only)
  | PARAM_RADIO_WRITEPOWER -- ^ @\/reader\/radio\/writePower@ 'Int32' (centi-dBm)
  | PARAM_READ_ASYNCOFFTIME -- ^ @\/reader\/read\/asyncOffTime@ 'Word32' (milliseconds)
  | PARAM_READ_ASYNCONTIME -- ^ @\/reader\/read\/asyncOnTime@ 'Word32' (milliseconds)
  | PARAM_READ_PLAN -- ^ @\/reader\/read\/plan@ 'ReadPlan'
  | PARAM_REGION_HOPTABLE -- ^ @\/reader\/region\/hopTable@ ['Word32'] (kHz)
  | PARAM_REGION_HOPTIME -- ^ @\/reader\/region\/hopTime@ 'Word32' (milliseconds)
  | PARAM_REGION_ID -- ^ @\/reader\/region\/id@ 'Region'
  | PARAM_REGION_SUPPORTEDREGIONS -- ^ @\/reader\/region\/supportedRegions@ ['Region'] (read-only)
  | PARAM_REGION_LBT_ENABLE -- ^ @\/reader\/region\/lbt\/enable@ 'Bool'
  | PARAM_READER_STATS_ENABLE -- ^ @\/reader\/stats\/enable@ (Not yet implemented)
  | PARAM_STATUS_ENABLE_ANTENNAREPORT -- ^ @\/reader\/status\/antennaEnable@ 'Bool'
  | PARAM_STATUS_ENABLE_FREQUENCYREPORT -- ^ @\/reader\/status\/frequencyEnable@ 'Bool'
  | PARAM_STATUS_ENABLE_TEMPERATUREREPORT -- ^ @\/reader\/status\/temperatureEnable@ 'Bool'
  | PARAM_TAGREADDATA_ENABLEREADFILTER -- ^ @\/reader\/tagReadData\/enableReadFilter@ 'Bool'
  | PARAM_TAGREADDATA_READFILTERTIMEOUT -- ^ @\/reader\/tagReadData\/readFilterTimeout@ 'Int32'
  | PARAM_TAGREADDATA_RECORDHIGHESTRSSI -- ^ @\/reader\/tagReadData\/recordHighestRssi@ 'Bool'
  | PARAM_TAGREADDATA_REPORTRSSIINDBM -- ^ @\/reader\/tagReadData\/reportRssiInDbm@ 'Bool'
  | PARAM_TAGREADATA_TAGOPFAILURECOUNT -- ^ @\/reader\/tagReadData\/tagopFailures@ 'Word16' (read-only)
  | PARAM_TAGREADATA_TAGOPSUCCESSCOUNT -- ^ @\/reader\/tagReadData\/tagopSuccesses@ 'Word16' (read-only)
  | PARAM_TAGREADDATA_UNIQUEBYANTENNA -- ^ @\/reader\/tagReadData\/uniqueByAntenna@ 'Bool'
  | PARAM_TAGREADDATA_UNIQUEBYDATA -- ^ @\/reader\/tagReadData\/uniqueByData@ 'Bool'
  | PARAM_TAGREADDATA_UNIQUEBYPROTOCOL -- ^ @\/reader\/tagReadData\/uniqueByProtocol@ 'Bool'
  | PARAM_TAGOP_ANTENNA -- ^ @\/reader\/tagop\/antenna@ 'Word8', or typedef 'AntennaPort'
  | PARAM_TAGOP_PROTOCOL -- ^ @\/reader\/tagop\/protocol@ 'TagProtocol'
  | PARAM_TRIGGER_READ_GPI -- ^ @\/reader\/trigger\/read\/Gpi@ ['Word8'], or typedef ['PinNumber']
  | PARAM_VERSION_HARDWARE -- ^ @\/reader\/version\/hardware@ 'Text' (read-only)
  | PARAM_VERSION_MODEL -- ^ @\/reader\/version\/model@ 'Text' (read-only)
  | PARAM_PRODUCT_GROUP -- ^ @\/reader\/version\/productGroup@ 'Text' (read-only)
  | PARAM_PRODUCT_GROUP_ID -- ^ @\/reader\/version\/productGroupID@ 'Word16' (read-only)
  | PARAM_PRODUCT_ID -- ^ @\/reader\/version\/productID@ 'Word16' (read-only)
  | PARAM_VERSION_SERIAL -- ^ @\/reader\/version\/serial@ 'Text'
  | PARAM_VERSION_SOFTWARE -- ^ @\/reader\/version\/software@ 'Text' (read-only)
  | PARAM_VERSION_SUPPORTEDPROTOCOLS -- ^ @\/reader\/version\/supportedProtocols@ ['TagProtocol'] (read-only)
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

instance Hashable Param where
  hash = fromEnum
  salt `hashWithSalt` p = salt `hashWithSalt` fromEnum p

toParam :: RawParam -> Param
toParam #{const TMR_PARAM_NONE} = PARAM_NONE
toParam #{const TMR_PARAM_BAUDRATE} = PARAM_BAUDRATE
toParam #{const TMR_PARAM_PROBEBAUDRATES} = PARAM_PROBEBAUDRATES
toParam #{const TMR_PARAM_COMMANDTIMEOUT} = PARAM_COMMANDTIMEOUT
toParam #{const TMR_PARAM_TRANSPORTTIMEOUT} = PARAM_TRANSPORTTIMEOUT
toParam #{const TMR_PARAM_POWERMODE} = PARAM_POWERMODE
toParam #{const TMR_PARAM_USERMODE} = PARAM_USERMODE
toParam #{const TMR_PARAM_ANTENNA_CHECKPORT} = PARAM_ANTENNA_CHECKPORT
toParam #{const TMR_PARAM_ANTENNA_PORTLIST} = PARAM_ANTENNA_PORTLIST
toParam #{const TMR_PARAM_ANTENNA_CONNECTEDPORTLIST} = PARAM_ANTENNA_CONNECTEDPORTLIST
toParam #{const TMR_PARAM_ANTENNA_PORTSWITCHGPOS} = PARAM_ANTENNA_PORTSWITCHGPOS
toParam #{const TMR_PARAM_ANTENNA_SETTLINGTIMELIST} = PARAM_ANTENNA_SETTLINGTIMELIST
toParam #{const TMR_PARAM_ANTENNA_RETURNLOSS} = PARAM_ANTENNA_RETURNLOSS
toParam #{const TMR_PARAM_ANTENNA_TXRXMAP} = PARAM_ANTENNA_TXRXMAP
toParam #{const TMR_PARAM_GPIO_INPUTLIST} = PARAM_GPIO_INPUTLIST
toParam #{const TMR_PARAM_GPIO_OUTPUTLIST} = PARAM_GPIO_OUTPUTLIST
toParam #{const TMR_PARAM_GEN2_ACCESSPASSWORD} = PARAM_GEN2_ACCESSPASSWORD
toParam #{const TMR_PARAM_GEN2_Q} = PARAM_GEN2_Q
toParam #{const TMR_PARAM_GEN2_TAGENCODING} = PARAM_GEN2_TAGENCODING
toParam #{const TMR_PARAM_GEN2_SESSION} = PARAM_GEN2_SESSION
toParam #{const TMR_PARAM_GEN2_TARGET} = PARAM_GEN2_TARGET
toParam #{const TMR_PARAM_GEN2_BLF} = PARAM_GEN2_BLF
toParam #{const TMR_PARAM_GEN2_TARI} = PARAM_GEN2_TARI
toParam #{const TMR_PARAM_GEN2_WRITEMODE} = PARAM_GEN2_WRITEMODE
toParam #{const TMR_PARAM_GEN2_BAP} = PARAM_GEN2_BAP
toParam #{const TMR_PARAM_GEN2_PROTOCOLEXTENSION} = PARAM_GEN2_PROTOCOLEXTENSION
toParam #{const TMR_PARAM_ISO180006B_BLF} = PARAM_ISO180006B_BLF
toParam #{const TMR_PARAM_ISO180006B_MODULATION_DEPTH} = PARAM_ISO180006B_MODULATION_DEPTH
toParam #{const TMR_PARAM_ISO180006B_DELIMITER} = PARAM_ISO180006B_DELIMITER
toParam #{const TMR_PARAM_READ_ASYNCOFFTIME} = PARAM_READ_ASYNCOFFTIME
toParam #{const TMR_PARAM_READ_ASYNCONTIME} = PARAM_READ_ASYNCONTIME
toParam #{const TMR_PARAM_READ_PLAN} = PARAM_READ_PLAN
toParam #{const TMR_PARAM_RADIO_ENABLEPOWERSAVE} = PARAM_RADIO_ENABLEPOWERSAVE
toParam #{const TMR_PARAM_RADIO_POWERMAX} = PARAM_RADIO_POWERMAX
toParam #{const TMR_PARAM_RADIO_POWERMIN} = PARAM_RADIO_POWERMIN
toParam #{const TMR_PARAM_RADIO_PORTREADPOWERLIST} = PARAM_RADIO_PORTREADPOWERLIST
toParam #{const TMR_PARAM_RADIO_PORTWRITEPOWERLIST} = PARAM_RADIO_PORTWRITEPOWERLIST
toParam #{const TMR_PARAM_RADIO_READPOWER} = PARAM_RADIO_READPOWER
toParam #{const TMR_PARAM_RADIO_WRITEPOWER} = PARAM_RADIO_WRITEPOWER
toParam #{const TMR_PARAM_RADIO_TEMPERATURE} = PARAM_RADIO_TEMPERATURE
toParam #{const TMR_PARAM_TAGREADDATA_RECORDHIGHESTRSSI} = PARAM_TAGREADDATA_RECORDHIGHESTRSSI
toParam #{const TMR_PARAM_TAGREADDATA_REPORTRSSIINDBM} = PARAM_TAGREADDATA_REPORTRSSIINDBM
toParam #{const TMR_PARAM_TAGREADDATA_UNIQUEBYANTENNA} = PARAM_TAGREADDATA_UNIQUEBYANTENNA
toParam #{const TMR_PARAM_TAGREADDATA_UNIQUEBYDATA} = PARAM_TAGREADDATA_UNIQUEBYDATA
toParam #{const TMR_PARAM_TAGOP_ANTENNA} = PARAM_TAGOP_ANTENNA
toParam #{const TMR_PARAM_TAGOP_PROTOCOL} = PARAM_TAGOP_PROTOCOL
toParam #{const TMR_PARAM_VERSION_HARDWARE} = PARAM_VERSION_HARDWARE
toParam #{const TMR_PARAM_VERSION_SERIAL} = PARAM_VERSION_SERIAL
toParam #{const TMR_PARAM_VERSION_MODEL} = PARAM_VERSION_MODEL
toParam #{const TMR_PARAM_VERSION_SOFTWARE} = PARAM_VERSION_SOFTWARE
toParam #{const TMR_PARAM_VERSION_SUPPORTEDPROTOCOLS} = PARAM_VERSION_SUPPORTEDPROTOCOLS
toParam #{const TMR_PARAM_REGION_HOPTABLE} = PARAM_REGION_HOPTABLE
toParam #{const TMR_PARAM_REGION_HOPTIME} = PARAM_REGION_HOPTIME
toParam #{const TMR_PARAM_REGION_ID} = PARAM_REGION_ID
toParam #{const TMR_PARAM_REGION_SUPPORTEDREGIONS} = PARAM_REGION_SUPPORTEDREGIONS
toParam #{const TMR_PARAM_REGION_LBT_ENABLE} = PARAM_REGION_LBT_ENABLE
toParam #{const TMR_PARAM_LICENSE_KEY} = PARAM_LICENSE_KEY
toParam #{const TMR_PARAM_USER_CONFIG} = PARAM_USER_CONFIG
toParam #{const TMR_PARAM_RADIO_ENABLESJC} = PARAM_RADIO_ENABLESJC
toParam #{const TMR_PARAM_EXTENDEDEPC} = PARAM_EXTENDEDEPC
toParam #{const TMR_PARAM_READER_STATISTICS} = PARAM_READER_STATISTICS
toParam #{const TMR_PARAM_READER_STATS} = PARAM_READER_STATS
toParam #{const TMR_PARAM_URI} = PARAM_URI
toParam #{const TMR_PARAM_PRODUCT_GROUP_ID} = PARAM_PRODUCT_GROUP_ID
toParam #{const TMR_PARAM_PRODUCT_GROUP} = PARAM_PRODUCT_GROUP
toParam #{const TMR_PARAM_PRODUCT_ID} = PARAM_PRODUCT_ID
toParam #{const TMR_PARAM_TAGREADATA_TAGOPSUCCESSCOUNT} = PARAM_TAGREADATA_TAGOPSUCCESSCOUNT
toParam #{const TMR_PARAM_TAGREADATA_TAGOPFAILURECOUNT} = PARAM_TAGREADATA_TAGOPFAILURECOUNT
toParam #{const TMR_PARAM_STATUS_ENABLE_ANTENNAREPORT} = PARAM_STATUS_ENABLE_ANTENNAREPORT
toParam #{const TMR_PARAM_STATUS_ENABLE_FREQUENCYREPORT} = PARAM_STATUS_ENABLE_FREQUENCYREPORT
toParam #{const TMR_PARAM_STATUS_ENABLE_TEMPERATUREREPORT} = PARAM_STATUS_ENABLE_TEMPERATUREREPORT
toParam #{const TMR_PARAM_TAGREADDATA_ENABLEREADFILTER} = PARAM_TAGREADDATA_ENABLEREADFILTER
toParam #{const TMR_PARAM_TAGREADDATA_READFILTERTIMEOUT} = PARAM_TAGREADDATA_READFILTERTIMEOUT
toParam #{const TMR_PARAM_TAGREADDATA_UNIQUEBYPROTOCOL} = PARAM_TAGREADDATA_UNIQUEBYPROTOCOL
toParam #{const TMR_PARAM_READER_DESCRIPTION} = PARAM_READER_DESCRIPTION
toParam #{const TMR_PARAM_READER_HOSTNAME} = PARAM_READER_HOSTNAME
toParam #{const TMR_PARAM_CURRENTTIME} = PARAM_CURRENTTIME
toParam #{const TMR_PARAM_READER_WRITE_REPLY_TIMEOUT} = PARAM_READER_WRITE_REPLY_TIMEOUT
toParam #{const TMR_PARAM_READER_WRITE_EARLY_EXIT} = PARAM_READER_WRITE_EARLY_EXIT
toParam #{const TMR_PARAM_READER_STATS_ENABLE} = PARAM_READER_STATS_ENABLE
toParam #{const TMR_PARAM_TRIGGER_READ_GPI} = PARAM_TRIGGER_READ_GPI
toParam #{const TMR_PARAM_METADATAFLAG} = PARAM_METADATAFLAG
toParam #{const TMR_PARAM_LICENSED_FEATURES} = PARAM_LICENSED_FEATURES
toParam _ = PARAM_NONE

fromParam :: Param -> RawParam
fromParam PARAM_NONE = #{const TMR_PARAM_NONE}
fromParam PARAM_BAUDRATE = #{const TMR_PARAM_BAUDRATE}
fromParam PARAM_PROBEBAUDRATES = #{const TMR_PARAM_PROBEBAUDRATES}
fromParam PARAM_COMMANDTIMEOUT = #{const TMR_PARAM_COMMANDTIMEOUT}
fromParam PARAM_TRANSPORTTIMEOUT = #{const TMR_PARAM_TRANSPORTTIMEOUT}
fromParam PARAM_POWERMODE = #{const TMR_PARAM_POWERMODE}
fromParam PARAM_USERMODE = #{const TMR_PARAM_USERMODE}
fromParam PARAM_ANTENNA_CHECKPORT = #{const TMR_PARAM_ANTENNA_CHECKPORT}
fromParam PARAM_ANTENNA_PORTLIST = #{const TMR_PARAM_ANTENNA_PORTLIST}
fromParam PARAM_ANTENNA_CONNECTEDPORTLIST = #{const TMR_PARAM_ANTENNA_CONNECTEDPORTLIST}
fromParam PARAM_ANTENNA_PORTSWITCHGPOS = #{const TMR_PARAM_ANTENNA_PORTSWITCHGPOS}
fromParam PARAM_ANTENNA_SETTLINGTIMELIST = #{const TMR_PARAM_ANTENNA_SETTLINGTIMELIST}
fromParam PARAM_ANTENNA_RETURNLOSS = #{const TMR_PARAM_ANTENNA_RETURNLOSS}
fromParam PARAM_ANTENNA_TXRXMAP = #{const TMR_PARAM_ANTENNA_TXRXMAP}
fromParam PARAM_GPIO_INPUTLIST = #{const TMR_PARAM_GPIO_INPUTLIST}
fromParam PARAM_GPIO_OUTPUTLIST = #{const TMR_PARAM_GPIO_OUTPUTLIST}
fromParam PARAM_GEN2_ACCESSPASSWORD = #{const TMR_PARAM_GEN2_ACCESSPASSWORD}
fromParam PARAM_GEN2_Q = #{const TMR_PARAM_GEN2_Q}
fromParam PARAM_GEN2_TAGENCODING = #{const TMR_PARAM_GEN2_TAGENCODING}
fromParam PARAM_GEN2_SESSION = #{const TMR_PARAM_GEN2_SESSION}
fromParam PARAM_GEN2_TARGET = #{const TMR_PARAM_GEN2_TARGET}
fromParam PARAM_GEN2_BLF = #{const TMR_PARAM_GEN2_BLF}
fromParam PARAM_GEN2_TARI = #{const TMR_PARAM_GEN2_TARI}
fromParam PARAM_GEN2_WRITEMODE = #{const TMR_PARAM_GEN2_WRITEMODE}
fromParam PARAM_GEN2_BAP = #{const TMR_PARAM_GEN2_BAP}
fromParam PARAM_GEN2_PROTOCOLEXTENSION = #{const TMR_PARAM_GEN2_PROTOCOLEXTENSION}
fromParam PARAM_ISO180006B_BLF = #{const TMR_PARAM_ISO180006B_BLF}
fromParam PARAM_ISO180006B_MODULATION_DEPTH = #{const TMR_PARAM_ISO180006B_MODULATION_DEPTH}
fromParam PARAM_ISO180006B_DELIMITER = #{const TMR_PARAM_ISO180006B_DELIMITER}
fromParam PARAM_READ_ASYNCOFFTIME = #{const TMR_PARAM_READ_ASYNCOFFTIME}
fromParam PARAM_READ_ASYNCONTIME = #{const TMR_PARAM_READ_ASYNCONTIME}
fromParam PARAM_READ_PLAN = #{const TMR_PARAM_READ_PLAN}
fromParam PARAM_RADIO_ENABLEPOWERSAVE = #{const TMR_PARAM_RADIO_ENABLEPOWERSAVE}
fromParam PARAM_RADIO_POWERMAX = #{const TMR_PARAM_RADIO_POWERMAX}
fromParam PARAM_RADIO_POWERMIN = #{const TMR_PARAM_RADIO_POWERMIN}
fromParam PARAM_RADIO_PORTREADPOWERLIST = #{const TMR_PARAM_RADIO_PORTREADPOWERLIST}
fromParam PARAM_RADIO_PORTWRITEPOWERLIST = #{const TMR_PARAM_RADIO_PORTWRITEPOWERLIST}
fromParam PARAM_RADIO_READPOWER = #{const TMR_PARAM_RADIO_READPOWER}
fromParam PARAM_RADIO_WRITEPOWER = #{const TMR_PARAM_RADIO_WRITEPOWER}
fromParam PARAM_RADIO_TEMPERATURE = #{const TMR_PARAM_RADIO_TEMPERATURE}
fromParam PARAM_TAGREADDATA_RECORDHIGHESTRSSI = #{const TMR_PARAM_TAGREADDATA_RECORDHIGHESTRSSI}
fromParam PARAM_TAGREADDATA_REPORTRSSIINDBM = #{const TMR_PARAM_TAGREADDATA_REPORTRSSIINDBM}
fromParam PARAM_TAGREADDATA_UNIQUEBYANTENNA = #{const TMR_PARAM_TAGREADDATA_UNIQUEBYANTENNA}
fromParam PARAM_TAGREADDATA_UNIQUEBYDATA = #{const TMR_PARAM_TAGREADDATA_UNIQUEBYDATA}
fromParam PARAM_TAGOP_ANTENNA = #{const TMR_PARAM_TAGOP_ANTENNA}
fromParam PARAM_TAGOP_PROTOCOL = #{const TMR_PARAM_TAGOP_PROTOCOL}
fromParam PARAM_VERSION_HARDWARE = #{const TMR_PARAM_VERSION_HARDWARE}
fromParam PARAM_VERSION_SERIAL = #{const TMR_PARAM_VERSION_SERIAL}
fromParam PARAM_VERSION_MODEL = #{const TMR_PARAM_VERSION_MODEL}
fromParam PARAM_VERSION_SOFTWARE = #{const TMR_PARAM_VERSION_SOFTWARE}
fromParam PARAM_VERSION_SUPPORTEDPROTOCOLS = #{const TMR_PARAM_VERSION_SUPPORTEDPROTOCOLS}
fromParam PARAM_REGION_HOPTABLE = #{const TMR_PARAM_REGION_HOPTABLE}
fromParam PARAM_REGION_HOPTIME = #{const TMR_PARAM_REGION_HOPTIME}
fromParam PARAM_REGION_ID = #{const TMR_PARAM_REGION_ID}
fromParam PARAM_REGION_SUPPORTEDREGIONS = #{const TMR_PARAM_REGION_SUPPORTEDREGIONS}
fromParam PARAM_REGION_LBT_ENABLE = #{const TMR_PARAM_REGION_LBT_ENABLE}
fromParam PARAM_LICENSE_KEY = #{const TMR_PARAM_LICENSE_KEY}
fromParam PARAM_USER_CONFIG = #{const TMR_PARAM_USER_CONFIG}
fromParam PARAM_RADIO_ENABLESJC = #{const TMR_PARAM_RADIO_ENABLESJC}
fromParam PARAM_EXTENDEDEPC = #{const TMR_PARAM_EXTENDEDEPC}
fromParam PARAM_READER_STATISTICS = #{const TMR_PARAM_READER_STATISTICS}
fromParam PARAM_READER_STATS = #{const TMR_PARAM_READER_STATS}
fromParam PARAM_URI = #{const TMR_PARAM_URI}
fromParam PARAM_PRODUCT_GROUP_ID = #{const TMR_PARAM_PRODUCT_GROUP_ID}
fromParam PARAM_PRODUCT_GROUP = #{const TMR_PARAM_PRODUCT_GROUP}
fromParam PARAM_PRODUCT_ID = #{const TMR_PARAM_PRODUCT_ID}
fromParam PARAM_TAGREADATA_TAGOPSUCCESSCOUNT = #{const TMR_PARAM_TAGREADATA_TAGOPSUCCESSCOUNT}
fromParam PARAM_TAGREADATA_TAGOPFAILURECOUNT = #{const TMR_PARAM_TAGREADATA_TAGOPFAILURECOUNT}
fromParam PARAM_STATUS_ENABLE_ANTENNAREPORT = #{const TMR_PARAM_STATUS_ENABLE_ANTENNAREPORT}
fromParam PARAM_STATUS_ENABLE_FREQUENCYREPORT = #{const TMR_PARAM_STATUS_ENABLE_FREQUENCYREPORT}
fromParam PARAM_STATUS_ENABLE_TEMPERATUREREPORT = #{const TMR_PARAM_STATUS_ENABLE_TEMPERATUREREPORT}
fromParam PARAM_TAGREADDATA_ENABLEREADFILTER = #{const TMR_PARAM_TAGREADDATA_ENABLEREADFILTER}
fromParam PARAM_TAGREADDATA_READFILTERTIMEOUT = #{const TMR_PARAM_TAGREADDATA_READFILTERTIMEOUT}
fromParam PARAM_TAGREADDATA_UNIQUEBYPROTOCOL = #{const TMR_PARAM_TAGREADDATA_UNIQUEBYPROTOCOL}
fromParam PARAM_READER_DESCRIPTION = #{const TMR_PARAM_READER_DESCRIPTION}
fromParam PARAM_READER_HOSTNAME = #{const TMR_PARAM_READER_HOSTNAME}
fromParam PARAM_CURRENTTIME = #{const TMR_PARAM_CURRENTTIME}
fromParam PARAM_READER_WRITE_REPLY_TIMEOUT = #{const TMR_PARAM_READER_WRITE_REPLY_TIMEOUT}
fromParam PARAM_READER_WRITE_EARLY_EXIT = #{const TMR_PARAM_READER_WRITE_EARLY_EXIT}
fromParam PARAM_READER_STATS_ENABLE = #{const TMR_PARAM_READER_STATS_ENABLE}
fromParam PARAM_TRIGGER_READ_GPI = #{const TMR_PARAM_TRIGGER_READ_GPI}
fromParam PARAM_METADATAFLAG = #{const TMR_PARAM_METADATAFLAG}
fromParam PARAM_LICENSED_FEATURES = #{const TMR_PARAM_LICENSED_FEATURES}

paramMax :: RawParam
paramMax = #{const TMR_PARAM_MAX}

-- | For parameters which are expressed in physical units,
-- returns a string describing the units.  Returns 'Nothing'
-- for parameters which are not expressed in physical units.
-- This can be useful for displaying in a user interface,
-- for example.
paramUnits :: Param -> Maybe Text
paramUnits PARAM_COMMANDTIMEOUT = Just "milliseconds"
paramUnits PARAM_TRANSPORTTIMEOUT = Just "milliseconds"
paramUnits PARAM_GEN2_BLF = Just "kHz"
paramUnits PARAM_READ_ASYNCOFFTIME = Just "milliseconds"
paramUnits PARAM_READ_ASYNCONTIME = Just "milliseconds"
paramUnits PARAM_RADIO_POWERMAX = Just "centi-dBm"
paramUnits PARAM_RADIO_POWERMIN = Just "centi-dBm"
paramUnits PARAM_RADIO_PORTREADPOWERLIST = Just "centi-dBm"
paramUnits PARAM_RADIO_PORTWRITEPOWERLIST = Just "centi-dBm"
paramUnits PARAM_RADIO_READPOWER = Just "centi-dBm"
paramUnits PARAM_RADIO_WRITEPOWER = Just "centi-dBm"
paramUnits PARAM_RADIO_TEMPERATURE = Just "degrees C"
paramUnits PARAM_REGION_HOPTABLE = Just "kHz"
paramUnits PARAM_REGION_HOPTIME = Just "milliseconds"
paramUnits PARAM_READER_WRITE_REPLY_TIMEOUT = Just "microseconds"
paramUnits _ = Nothing

-- | The Haskell data type expected for a particular parameter.
data ParamType =
    ParamTypeBool
  | ParamTypeInt16
  | ParamTypeInt32
  | ParamTypeInt8
  | ParamTypeMetadataFlagList
  | ParamTypeReadPlan
  | ParamTypeRegion
  | ParamTypeRegionList
  | ParamTypeTagProtocol
  | ParamTypeTagProtocolList
  | ParamTypeText
  | ParamTypeWord16
  | ParamTypeWord32
  | ParamTypeWord32List
  | ParamTypeWord8
  | ParamTypeWord8List
  | ParamTypeUnimplemented
  deriving (Eq, Ord, Show, Read, Bounded, Enum)

-- | Indicates the type expected for a given parameter.
paramType :: Param -> ParamType
paramType PARAM_BAUDRATE = ParamTypeWord32
paramType PARAM_PROBEBAUDRATES = ParamTypeWord32List
paramType PARAM_COMMANDTIMEOUT = ParamTypeWord32
paramType PARAM_TRANSPORTTIMEOUT = ParamTypeWord32
paramType PARAM_ANTENNA_CHECKPORT = ParamTypeBool
paramType PARAM_ANTENNA_PORTLIST = ParamTypeWord8List
paramType PARAM_ANTENNA_CONNECTEDPORTLIST = ParamTypeWord8List
paramType PARAM_ANTENNA_PORTSWITCHGPOS = ParamTypeWord8List
paramType PARAM_GPIO_INPUTLIST = ParamTypeWord8List
paramType PARAM_GPIO_OUTPUTLIST = ParamTypeWord8List
paramType PARAM_GEN2_ACCESSPASSWORD = ParamTypeWord32
paramType PARAM_READ_ASYNCOFFTIME = ParamTypeWord32
paramType PARAM_READ_ASYNCONTIME = ParamTypeWord32
paramType PARAM_READ_PLAN = ParamTypeReadPlan
paramType PARAM_RADIO_ENABLEPOWERSAVE = ParamTypeBool
paramType PARAM_RADIO_POWERMAX = ParamTypeInt16
paramType PARAM_RADIO_POWERMIN = ParamTypeInt16
paramType PARAM_RADIO_READPOWER = ParamTypeInt32
paramType PARAM_RADIO_WRITEPOWER = ParamTypeInt32
paramType PARAM_RADIO_TEMPERATURE = ParamTypeInt8
paramType PARAM_TAGREADDATA_RECORDHIGHESTRSSI = ParamTypeBool
paramType PARAM_TAGREADDATA_REPORTRSSIINDBM = ParamTypeBool
paramType PARAM_TAGREADDATA_UNIQUEBYANTENNA = ParamTypeBool
paramType PARAM_TAGREADDATA_UNIQUEBYDATA = ParamTypeBool
paramType PARAM_TAGOP_ANTENNA = ParamTypeWord8
paramType PARAM_TAGOP_PROTOCOL = ParamTypeTagProtocol
paramType PARAM_VERSION_HARDWARE = ParamTypeText
paramType PARAM_VERSION_SERIAL = ParamTypeText
paramType PARAM_VERSION_MODEL = ParamTypeText
paramType PARAM_VERSION_SOFTWARE = ParamTypeText
paramType PARAM_VERSION_SUPPORTEDPROTOCOLS = ParamTypeTagProtocolList
paramType PARAM_REGION_HOPTABLE = ParamTypeWord32List
paramType PARAM_REGION_HOPTIME = ParamTypeWord32
paramType PARAM_REGION_ID = ParamTypeRegion
paramType PARAM_REGION_SUPPORTEDREGIONS = ParamTypeRegionList
paramType PARAM_REGION_LBT_ENABLE = ParamTypeBool
paramType PARAM_LICENSE_KEY = ParamTypeWord8List
paramType PARAM_RADIO_ENABLESJC = ParamTypeBool
paramType PARAM_EXTENDEDEPC = ParamTypeBool
paramType PARAM_URI = ParamTypeText
paramType PARAM_PRODUCT_GROUP_ID = ParamTypeWord16
paramType PARAM_PRODUCT_GROUP = ParamTypeText
paramType PARAM_PRODUCT_ID = ParamTypeWord16
paramType PARAM_TAGREADATA_TAGOPSUCCESSCOUNT = ParamTypeWord16
paramType PARAM_TAGREADATA_TAGOPFAILURECOUNT = ParamTypeWord16
paramType PARAM_STATUS_ENABLE_ANTENNAREPORT = ParamTypeBool
paramType PARAM_STATUS_ENABLE_FREQUENCYREPORT = ParamTypeBool
paramType PARAM_STATUS_ENABLE_TEMPERATUREREPORT = ParamTypeBool
paramType PARAM_TAGREADDATA_ENABLEREADFILTER = ParamTypeBool
paramType PARAM_TAGREADDATA_READFILTERTIMEOUT = ParamTypeInt32
paramType PARAM_TAGREADDATA_UNIQUEBYPROTOCOL = ParamTypeBool
paramType PARAM_READER_DESCRIPTION = ParamTypeText
paramType PARAM_READER_HOSTNAME = ParamTypeText
paramType PARAM_READER_WRITE_REPLY_TIMEOUT = ParamTypeWord16
paramType PARAM_READER_WRITE_EARLY_EXIT = ParamTypeBool
paramType PARAM_TRIGGER_READ_GPI = ParamTypeWord8List
paramType PARAM_METADATAFLAG = ParamTypeMetadataFlagList
paramType PARAM_LICENSED_FEATURES = ParamTypeWord8List
paramType _ = ParamTypeUnimplemented

-- | A textual representation of the Haskell type corresponding
-- to a particular 'ParamType'.
displayParamType :: ParamType -> Text
displayParamType ParamTypeBool = "Bool"
displayParamType ParamTypeInt16 = "Int16"
displayParamType ParamTypeInt32 = "Int32"
displayParamType ParamTypeInt8 = "Int8"
displayParamType ParamTypeReadPlan = "ReadPlan"
displayParamType ParamTypeRegion = "Region"
displayParamType ParamTypeTagProtocol = "TagProtocol"
displayParamType ParamTypeText = "Text"
displayParamType ParamTypeWord16 = "Word16"
displayParamType ParamTypeWord32 = "Word32"
displayParamType ParamTypeWord8 = "Word8"
displayParamType ParamTypeMetadataFlagList = "[MetadataFlag]"
displayParamType ParamTypeRegionList = "[Region]"
displayParamType ParamTypeTagProtocolList = "[TagProtocol]"
displayParamType ParamTypeWord32List = "[Word32]"
displayParamType ParamTypeWord8List = "[Word8]"
displayParamType _ = "(Not yet implemented)"

instance ParamValue Bool where
  pType _ = ParamTypeBool
  pGet f = alloca $ \p -> f (castPtr (p :: Ptr CBool)) >> toBool <$> peek p
  pSet x f = alloca $ \p -> poke p (fromBool x :: CBool) >> f (castPtr p)

instance ParamValue Int16 where
  pType _ = ParamTypeInt16
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue Int32 where
  pType _ = ParamTypeInt32
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue Int8 where
  pType _ = ParamTypeInt8
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue ReadPlan where
  pType _ = ParamTypeReadPlan
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = bracketOnError (new x) free (f . castPtr)

instance ParamValue Region where
  pType _ = ParamTypeRegion
  pGet f = alloca $ \p -> f (castPtr p) >> toRegion <$> peek p
  pSet x f = alloca $ \p -> poke p (fromRegion x) >> f (castPtr p)

instance ParamValue TagProtocol where
  pType _ = ParamTypeTagProtocol
  pGet f = alloca $ \p -> f (castPtr p) >> toTagProtocol <$> peek p
  pSet x f = alloca $ \p -> poke p (fromTagProtocol x) >> f (castPtr p)

instance ParamValue Text where
  pType _ = ParamTypeText

  pGet f = do
    let maxLen = maxBound :: Word16
    allocaBytes (fromIntegral maxLen) $ \storage -> do
      let lst = List16
                { l16_list = castPtr storage
                , l16_max = maxLen
                , l16_len = 0 -- unused for TMR_String
                }
      with lst $ \p -> do
        f (castPtr p)
        textFromCString storage

  pSet x f = do
    let bs = textToBS x
    B.useAsCString bs $ \cs -> do
      len' <- castLen "Text" (1 + B.length bs)
      let lst = List16
                { l16_list = castPtr cs
                , l16_max = len'
                , l16_len = 0 -- unused for TMR_String
                }
      with lst $ \p -> f (castPtr p)

instance ParamValue Word16 where
  pType _ = ParamTypeWord16
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue Word32 where
  pType _ = ParamTypeWord32
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue Word8 where
  pType _ = ParamTypeWord8
  pGet f = alloca $ \p -> f (castPtr p) >> peek p
  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)

instance ParamValue [MetadataFlag] where
  pType _ = ParamTypeMetadataFlagList
  pGet f = alloca $ \p -> f (castPtr p) >> unpackFlags <$> peek p
  pSet x f = alloca $ \p -> poke p (packFlags x) >> f (castPtr p)

instance ParamValue [Region] where
  pType _ = ParamTypeRegionList
  pGet f = map toRegion <$> getList8 f
  pSet x f = setList8 "[Region]" (map fromRegion x) f

instance ParamValue [TagProtocol] where
  pType _ = ParamTypeTagProtocolList
  pGet f = map toTagProtocol <$> getList8 f
  pSet x f = setList8 "[TagProtocol]" (map fromTagProtocol x) f

instance ParamValue [Word32] where
  pType _ = ParamTypeWord32List
  pGet = getList16
  pSet = setList16 "[Word32]"

instance ParamValue [Word8] where
  pType _ = ParamTypeWord8List
  pGet = getList16
  pSet = setList16 "[Word8]"

