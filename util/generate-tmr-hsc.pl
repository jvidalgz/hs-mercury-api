#!/usr/bin/perl -w

use FindBin;

my $rootDir = "$FindBin::Bin/..";
my $apiDir = "$rootDir/cbits/api";
my $glueDir = "$rootDir/cbits/glue";
my $outputFile = "$rootDir/src/System/Hardware/MercuryApi/Generated.hsc";

my @errorTypes = ("SUCCESS_TYPE");
my @errorCodes = ("SUCCESS");
my %errorCodes = ("SUCCESS" => "Success!");
my @glueTypes = ();
my %glueTypes = ();
my @glueCodes = ();
my %glueCodes = ();

my @params = ();
my %params = ();
my %paramType = ();

my @lines = ();

my $nyi = "(Not yet implemented)";

# Additional statuses of type ERROR_TYPE_BINDING.  These statuses are thrown
# only from Haskell code, not C code, so they don't have a numeric code.
my %haskellCodes = (
    "ERROR_UNIMPLEMENTED_PARAM" =>
    "The given parameter is not yet implemented in the Haskell binding.",
    "ERROR_INVALID_PARAM_TYPE" =>
    "The parameter value was not of the type expected."
    );

my %toHaskellType = (
    "int8_t"   => "Int8",
    "int16_t"  => "Int16",
    "int32_t"  => "Int32",
    "uint8_t"  => "Word8",
    "uint16_t" => "Word16",
    "uint32_t" => "Word32",
    );

sub readStatus {
    open F, "$apiDir/tmr_status.h" or die;
    my $comment = "";
    while (<F>) {
        if (/^#define TMR_(ERROR_TYPE_[A-Z]+)/) {
            push @errorTypes, $1;
        } elsif (m%^/\*\*(.*?)\s+\*/%) {
            $comment = $1;
        } elsif (/^#define TMR_(ERROR_[A-Z0-9_]+)\s+/) {
            push @errorCodes, $1;
            $errorCodes{$1} = $comment;
            $comment = "";
        } else {
            $comment = "";
        }
    }
    close F;
}

sub parseParamComment {
    my ($c) = @_;
    if ($c =~ /^(\"[^\"]+\"),\s+(\w+)/) {
        my ($quoted, $type) = ($1, $2);
        my $haskellType;
        if (exists $toHaskellType{$type}) {
            $haskellType = $toHaskellType{$type};
        } else {
            $haskellType = $nyi;
        }
        return ($haskellType, "$quoted, $haskellType");
    } else {
        return ("", $c);
    }
}

sub readParams {
    open F, "$apiDir/tmr_params.h" or die;
    my $comment = "";
    while (<F>) {
        if (m%^\s*/\*\*\s*(.*?)\s*\*+/%) {
            $comment = $1;
        } elsif (/^\s*TMR_(PARAM_[A-Z0-9_]+)/) {
            unless ($1 eq "PARAM_MIN" or
                    $1 eq "PARAM_END" or
                    $1 eq "PARAM_MAX") {
                my $p = $1;
                push @params, $p;
                my ($t, $c) = parseParamComment ($comment);
                $params{$p} = $c;
                $paramType{$p} = $t;
            }
            $comment = "";
        } else {
            $comment = "";
        }
    }
    close F;
}

sub readGlue {
    open F, "$glueDir/glue.h" or die;
    my $comment = "";
    while (<F>) {
        if (/^#define (ERROR_TYPE_[A-Z]+)/) {
            push @glueTypes, $1;
            $glueTypes{$1} = $comment;
            $comment = "";
        } elsif (m%^/\*\*\s*(.*?)\s*\*/%) {
            $comment = $1;
        } elsif (/^#define (ERROR_[A-Z0-9_]+)\s+/) {
            push @glueCodes, $1;
            $glueCodes{$1} = $comment;
            $comment = "";
        } else {
            $comment = "";
        }
    }
    close F;
}

sub emit {
    my ($s) = @_;
    push @lines, $s;
}

sub emitHeader {
    emit "{-# LANGUAGE OverloadedStrings #-}";
    emit "-- Automatically generated by util/generate-tmr-hsc.pl";
    emit "module System.Hardware.MercuryApi.Generated where";
    emit "";
    emit "import Data.Hashable";
    emit "import Data.Text (Text)";
    emit "import Data.Word";
    emit "import Foreign";
    emit "import Foreign.C";
    emit "";
    emit "#include <tm_reader.h>";
    emit "#include <glue.h>";
    emit "#include <stdbool.h>";
    emit "";
    emit "type CBool = #{type bool}";
    emit "newtype ReaderEtc = ReaderEtc ()";
    emit "";
    emit "sizeofReaderEtc :: Int";
    emit "sizeofReaderEtc = #{size ReaderEtc}";
    emit "";
    emit "uriPtr :: Ptr ReaderEtc -> CString";
    emit "uriPtr = #{ptr ReaderEtc, reader.uri}";
    emit "";
}

sub dumpOutput {
    open F, ">$outputFile" or die;
    for my $line (@lines) {
        print F "$line\n";
    }
    close F;
}

sub emitEnum1 {
    my ($constructors, $comments, $sep) = @_;
    for my $con (@$constructors) {
        my $comment = "";
        if (exists $comments->{$con} and $comments->{$con} ne "") {
            $comment = " -- ^ " . $comments->{$con};
        }
        emit "  $sep $con$comment";
        $sep = "|";
    }
}

sub emitEnum {
    my ($constructors, $comments) = @_;
    emitEnum1 ($constructors, $comments, " ");
}

sub emitEnumCont {
    my ($constructors, $comments) = @_;
    emitEnum1 ($constructors, $comments, "|");
}

sub emitTo {
    my ($func, $prefix, $constructors) = @_;
    for my $con (@$constructors) {
        emit "$func #{const $prefix$con} = $con";
    }
}

sub emitFrom {
    my ($func, $prefix, $constructors) = @_;
    for my $con (@$constructors) {
        emit "$func $con = #{const $prefix$con}";
    }
}

sub emitStatus {
    emit "data StatusType =";
    emitEnum (\@errorTypes, {});
    emitEnumCont (\@glueTypes, \%glueTypes);
    emit "  | ERROR_TYPE_UNKNOWN -- ^ Not a recognized status type";
    emit "  deriving (Eq, Ord, Show, Read, Bounded, Enum)";
    emit "";

    emit "toStatusType :: Word32 -> StatusType";
    emitTo ("toStatusType", "TMR_", \@errorTypes);
    emitTo ("toStatusType", "",     \@glueTypes);
    emit "toStatusType _ = ERROR_TYPE_UNKNOWN";
    emit "";

    emit "data Status =";
    emitEnum (\@errorCodes, \%errorCodes);
    emitEnumCont (\@glueCodes, \%glueCodes);
    emitEnumCont ([sort keys %haskellCodes], \%haskellCodes);
    emit "  | ERROR_UNKNOWN Word32 -- ^ C API returned an unrecognized status code";
    emit "  deriving (Eq, Ord, Show, Read)";
    emit "";

    emit "toStatus :: Word32 -> Status";
    emitTo ("toStatus", "TMR_", \@errorCodes);
    emitTo ("toStatus", "",     \@glueCodes);
    emit "toStatus x = ERROR_UNKNOWN x";
    emit "";
}

sub emitParams {
    emit "type RawParam = #{type TMR_Param}";
    emit "";

    emit "data Param =";
    emitEnum (\@params, \%params);
    emit "  deriving (Eq, Ord, Show, Read, Bounded, Enum)";
    emit "";

    emit "instance Hashable Param where";
    emit "  hash = fromEnum";
    emit "  salt `hashWithSalt` p = salt `hashWithSalt` fromEnum p";
    emit "";

    emit "toParam :: RawParam -> Param";
    emitTo ("toParam", "TMR_", \@params);
    emit "toParam _ = PARAM_NONE";
    emit "";

    emit "fromParam :: Param -> RawParam";
    emitFrom ("fromParam", "TMR_", \@params);
    emit "";

    emit "paramMax :: RawParam";
    emit "paramMax = #{const TMR_PARAM_MAX}";
    emit "";
}

sub emitParamTypes {
    emit "data ParamType =";
    emitEnum ([map ("ParamType$_", sort values %toHaskellType)], {});
    emit "  | ParamTypeUnimplemented";
    emit "  deriving (Eq, Ord, Show, Read, Bounded, Enum)";
    emit "";

    emit "paramType :: Param -> ParamType";
    foreach my $param (@params) {
        my $type = $paramType{$param};
        if ($type =~ /^\w+$/) {
            emit "paramType $param = ParamType$type";
        }
    }
    emit "paramType _ = ParamTypeUnimplemented";
    emit "";

    emit "paramTypeDisplay :: ParamType -> Text";
    foreach my $paramType (sort values %toHaskellType) {
        if ($paramType =~ /^\w+$/) {
            emit "paramTypeDisplay ParamType$paramType = \"$paramType\"";
        }
    }
    emit "paramTypeDisplay _ = \"$nyi\"";
    emit "";

    emit "class ParamValue a where";
    emit "  pType :: a -> ParamType";
    emit "  pGet :: (Ptr () -> IO ()) -> IO a";
    emit "  pSet :: a -> (Ptr () -> IO ()) -> IO ()";
    emit "";

    foreach my $paramType (sort values %toHaskellType) {
        if ($paramType =~ /^\w+$/) {
            emit "instance ParamValue $paramType where";
            emit "  pType _ = ParamType$paramType";
            emit '  pGet f = alloca $ \p -> f (castPtr p) >> peek p';
            emit '  pSet x f = alloca $ \p -> poke p x >> f (castPtr p)';
            emit "";
        }
    }
}

readStatus();
readParams();
readGlue();

emitHeader();
emitStatus();
emitParams();
emitParamTypes();

dumpOutput();
